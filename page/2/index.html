<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    悠悠我心</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay loop muted data-autoplay="" poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">悠悠我心</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="悠悠我心"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/hello-world/">Hello World</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/hello-world/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <blockquote>
<p>今天是个人博客开通的第一天，搞了半天终于好了，好激动！！！</p>
</blockquote>
<blockquote>
<p>我有一头<strong>小毛驴</strong>，可是我从来都不骑。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/hello-world/" data-id="cjqrd1sfj000927lb75afjybw" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-hello-world的副本" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/hello-world的副本/">Hello World</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/hello-world的副本/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <blockquote>
<p>今天是个人博客开通的第一天，搞了半天终于好了，好激动！！！</p>
</blockquote>
<blockquote>
<p>我有一头<strong>小毛驴</strong>，可是我从来都不骑。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/hello-world的副本/" data-id="cjqrd1sfk000a27lbnrgmzagb" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-iOS 宏(define)与常量(const)以及extern" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/iOS 宏(define)与常量(const)以及extern/">Hello World</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/iOS 宏(define)与常量(const)以及extern/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>###思考下，下面的有什么不同，分别在什么时候使用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define HSCoder @&quot;汉斯哈哈哈&quot;</span><br><span class="line">NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">extern NSString *HSCoder;</span><br><span class="line">extern const NSString *HSCoder;</span><br><span class="line"></span><br><span class="line">static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line"></span><br><span class="line">const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br></pre></td></tr></table></figure></p>
<p>###当我们想全局共用一些数据时，可以用宏、变量、常量</p>
<p>宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define HSCoder @&quot;汉斯哈哈哈&quot;</span><br></pre></td></tr></table></figure></p>
<p>变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br></pre></td></tr></table></figure></p>
<p>常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四种写法：</span><br><span class="line">static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br></pre></td></tr></table></figure></p>
<p>宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大</p>
<p>变量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段会执行类型检查</p>
<p>常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查</p>
<p>###const和static const区分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; //本文件内部的全局常量</span><br><span class="line"></span><br><span class="line">static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//用static修饰后，不能提供外界访问,只能在本文件内访问,或者导入本文件可用（iOS中只有.h文件的导入，所以定义在.h中，如果导入.h头文件那么外部也可以用，如果定义在.m则只能在.m本文件内部使用）</span><br></pre></td></tr></table></figure></p>
<p>###const修饰位置<br>const右边的总不能被修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改</span><br><span class="line"></span><br><span class="line">2.NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改</span><br><span class="line"></span><br><span class="line">3.NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;;</span><br><span class="line">&quot;HSCoder&quot;不能被修改，&quot;*HSCoder&quot;能被修改</span><br></pre></td></tr></table></figure></p>
<h4 id="“static作用”"><a href="#“static作用”" class="headerlink" title="“static作用”:"></a>“static作用”:</h4><ul>
<li>修饰局部变量：</li>
</ul>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
<p>3.改变局部变量的作用域。</p>
<ul>
<li>修饰全局变量</li>
</ul>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<p>2.避免重复定义全局变量</p>
<p>####const作用：限制类型</p>
<ul>
<li>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li>2.被const修饰的变量是只读的。</li>
</ul>
<p>####”extern作用”:</p>
<ul>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
<li>“extern工作原理”:</li>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
<p>知识补充：<br>对于指针a来说，*a就是指针a所指向的内存空间存储的值,&amp;a就是存储这个变量的内存地址,a是指针名</p>
<p>staic和const联合的作用:声明一个静态的全局只读常量,在”一个文件中”经常使用的字符串常量，可以使用static与const组合</p>
<p>extern与const组合的作用：在”多个文件中”经常使用的同一个字符串常量，可以使用extern与const组合。</p>
<ul>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/iOS 宏(define)与常量(const)以及extern/" data-id="cjqrd1sfm000b27lb6t1a0jg4" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-iOS之创建一个常驻线程" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/iOS之创建一个常驻线程/">iOS之创建一个常驻线程</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/iOS之创建一个常驻线程/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>常驻线程有什么用呢？<br>让一个一直存在的子线程，等待其他线程发来消息，处理其他事件。</p>
<p>注意 ：不要使用GCD的global队列创建常驻线程<br>原因：global全局队列，整个工程共用的队列，队列里的所有线程都会放进一个线程池中，当线程池满了的时候，就会进入等待状态，后面加进来的block就不会创建新的线程执行了 等待前面的任务执行完成，才会继续执行。如果线程池中的线程长时间不结束，后续堆积的任务会越来越多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@interface LongThreadDemoController ()</span><br><span class="line">@property (nonatomic, strong) NSThread *thread;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LongThreadDemoController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">self.title = @&quot;常驻线程Demo&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadRunloopPoint:(id)__unused object&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">[[NSThread currentThread] setName:@&quot;changzhuThread&quot;];</span><br><span class="line">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">//// 这里主要是监听某个 port，目的是让这个 Thread 不会回收</span><br><span class="line">[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runLoop run];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSThread *)thread&#123;</span><br><span class="line"></span><br><span class="line">if(!_thread)&#123;</span><br><span class="line">_thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadRunloopPoint:) object:nil];</span><br><span class="line">[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">return _thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/iOS之创建一个常驻线程/" data-id="cjqrd1sfn000c27lb1m8lrszg" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-iOS图片拉伸" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/iOS图片拉伸/">iOS图片拉伸</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/iOS图片拉伸/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UIImage * img = [UIImage imageNamed:@&quot;3X&quot;];</span><br><span class="line">float w = img.size.width;</span><br><span class="line">float h = img.size.height;</span><br><span class="line"></span><br><span class="line">//图片拉伸 当imgview的frame跟img不一样大时就会拉伸图片来填充</span><br><span class="line">//第一个参数 UIEdgeInsets 是规定上下左右到img边的部分不拉伸受到保护 中间部分进行拉伸</span><br><span class="line">//UIImageResizingModeStretch 拉伸</span><br><span class="line">//UIImageResizingModeTile 平铺</span><br><span class="line">UIImage * newImg = [img resizableImageWithCapInsets:</span><br><span class="line">UIEdgeInsetsMake(h * 0.5, w * 0.5, h * 0.5, w * 0.5)         </span><br><span class="line">resizingMode:</span><br><span class="line">UIImageResizingModeStretch];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/iOS图片拉伸/" data-id="cjqrd1sfo000d27lbnsgg4src" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-tableviewcell注册和不注册的区别及用法" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/tableviewcell注册和不注册的区别及用法/">tableviewcell注册和不注册的区别及用法</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/tableviewcell注册和不注册的区别及用法/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>注册和不注册的区别主要看下面这两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; </span><br><span class="line">// Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.</span><br><span class="line">(返回给代理一个已经分配的cell，代替一个新的cell，如果没有已分配的cell，则返回nil，使用这个方法就不需要注册了)</span><br><span class="line"></span><br><span class="line">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); </span><br><span class="line">// newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered  </span><br><span class="line">如果cell的identifier是注册过的，那么这个新列出的方法保证返回一个cell (有分配的就返回已分配的cell，没有返回新的cell)并适当调整大小，可省略cell空值判断步骤，用这个方法cell必须注册,不是自定义的cell，UITableViewCell也要注册</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/tableviewcell注册和不注册的区别及用法/" data-id="cjqrd1sfq000f27lbbmn46w3m" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-代码修改xib约束的值注意" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/代码修改xib约束的值注意/">Hello World</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/代码修改xib约束的值注意/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>有时候在初始化中或者viewdidload中直接改变top.constant的值没有用，可能是因为代码设置后 xib后更新（xib加载在代码设置后） 这个时候使用延迟加载即可 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(modifyConstant) withObject:nil afterDelay:0.1];//延迟加载,执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)modifyConstant&#123;</span><br><span class="line">self.topSafeH.constant += 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/代码修改xib约束的值注意/" data-id="cjqrd1sfr000g27lbaae7e6s5" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-NSOperation、NSOperationQueue" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/NSOperation、NSOperationQueue/">Hello World</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/NSOperation、NSOperationQueue/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>####一、 为什么要使用 NSOperation、NSOperationQueue<br>NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。<br>可添加完成的代码块，在操作完成后执行。<br>添加操作之间的依赖关系，方便的控制执行顺序。<br>设定操作执行的优先级。<br>可以很方便的取消一个操作的执行。<br>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</p>
<p>####二、同步异步以及并行串行的区别<br>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态<br>并行串行是指有多个线程的任务的执行方式，串行则多个任务按顺序执行，并行则多个任务会同时执行</p>
<h4 id="三、-NSOperation-实现多线程的使用步骤分为三步："><a href="#三、-NSOperation-实现多线程的使用步骤分为三步：" class="headerlink" title="三、 NSOperation 实现多线程的使用步骤分为三步："></a>三、 NSOperation 实现多线程的使用步骤分为三步：</h4><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p>1、创建操作：先将需要执行的操作封装到一个NSOperation 对象中。<br>2、创建队列：创建NSOperationQueue对象。<br>3、将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。</p>
<p>之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p>
<p>####四、线程死锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//    NSLog(@&quot;1&quot;);</span><br><span class="line">//    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//        NSLog(@&quot;2&quot;);</span><br><span class="line">//    &#125;);</span><br><span class="line">//    NSLog(@&quot;3&quot;);</span><br></pre></td></tr></table></figure></p>
<p>主线程是串行队列, 一个任务执行完成才能往下执行, 同步线程是一个任务A ,里面的block是同步线程插入到当前线程的另一个任务B ,A要等B执行完才返回 ,B要等A执行完才能执行 ,会相互等待 造成死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">//    创建操作</span><br><span class="line">//    [self useInvocationOperation];</span><br><span class="line">////    NSOperation单独使用 同步执行 等待结果返回后执行后面语句</span><br><span class="line">//    NSLog(@&quot;下一个语句&quot;);</span><br><span class="line"></span><br><span class="line">//    [self useBlockOperation];</span><br><span class="line"></span><br><span class="line">//    创建队列</span><br><span class="line">//    [self addOperationToQueue];</span><br><span class="line"></span><br><span class="line">//    添加依赖</span><br><span class="line">//    [self addDependency];</span><br><span class="line"></span><br><span class="line">//    优先级</span><br><span class="line">//    [self queuePriority];</span><br><span class="line"></span><br><span class="line">//    线程间通讯</span><br><span class="line">//    [self communication];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    线程死锁：主线程是串行队列 一个任务执行完成才能往下执行 同步线程是一个任务A 里面的block是同步线程插入到当前线程的另一个任务B A要等B执行完才返回 B要等A执行完才能执行 会相互等待 造成死锁</span><br><span class="line">//    NSLog(@&quot;1&quot;);</span><br><span class="line">//    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//        NSLog(@&quot;2&quot;);</span><br><span class="line">//    &#125;);</span><br><span class="line">//    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark -  创建操作</span><br><span class="line">//NSOperation 单独使用时系统同步执行操作</span><br><span class="line">//NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。</span><br><span class="line">//使用子类 NSInvocationOperation</span><br><span class="line">//使用子类 NSBlockOperation</span><br><span class="line">//自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。</span><br><span class="line">- (void)useInvocationOperation&#123;</span><br><span class="line">NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];</span><br><span class="line"></span><br><span class="line">//    开始操作</span><br><span class="line">[invocationOperation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行(完成顺序是不一定的)。只有当所有相关的操作已经完成执行时，才视为完成</span><br><span class="line"></span><br><span class="line">//一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</span><br><span class="line">- (void)useBlockOperation&#123;</span><br><span class="line">NSBlockOperation * blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;blockOperation---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.添加额外的操作</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    调用 start 方法开始执行操作</span><br><span class="line">[blockOperation start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)useCustomOperation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 创建队列</span><br><span class="line">//NSOperationQueue 创建的自定义队列同时具有串行、并发功能，通过设置属性maxConcurrentOperationCount（最大并发操作数）用来控制一个特定队列中可以有多少个操作同时参与并发执行。</span><br><span class="line">//当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</span><br><span class="line">//1、- (void)addOperation:(NSOperation *)op;</span><br><span class="line">//2、- (void)addOperationWithBlock:(void (^)(void))block;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 使用 addOperation: 将操作加入到操作队列中</span><br><span class="line">*/</span><br><span class="line">- (void)addOperationToQueue &#123;</span><br><span class="line"></span><br><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">//    设置最大并发操作数 来控制队列的串行或者并发</span><br><span class="line">queue.maxConcurrentOperationCount = 1;</span><br><span class="line">//    queue.maxConcurrentOperationCount = 8;</span><br><span class="line">// 2.创建操作</span><br><span class="line">// 使用 NSInvocationOperation 创建操作1</span><br><span class="line">NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];</span><br><span class="line"></span><br><span class="line">// 使用 NSInvocationOperation 创建操作2</span><br><span class="line">NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];</span><br><span class="line"></span><br><span class="line">op1.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">op2.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line"></span><br><span class="line">// 使用 NSBlockOperation 创建操作3</span><br><span class="line">NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[op3 addExecutionBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start</span><br><span class="line">[queue addOperation:op2]; // [op2 start]</span><br><span class="line">[queue addOperation:op3]; // [op3 start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 使用 addOperationWithBlock: 将操作加入到操作队列中</span><br><span class="line">无需自己创建操作对象 直接将操作放到block中</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">- (void)addOperationWithBlockToQueue &#123;</span><br><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">// 2.使用 addOperationWithBlock: 添加操作到队列中</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSOperation 操作依赖</span><br><span class="line">//NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</span><br><span class="line">//- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</span><br><span class="line">//- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。</span><br><span class="line">//@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。</span><br><span class="line"></span><br><span class="line">- (void)addDependency &#123;</span><br><span class="line"></span><br><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">// 2.创建操作</span><br><span class="line">NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.添加依赖</span><br><span class="line">[op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">// 4.添加操作到队列中</span><br><span class="line">[queue addOperation:op1];</span><br><span class="line">[queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSOperation 优先级 &amp; 服务质量（只是尽可能的 并不是绝对的）</span><br><span class="line">//NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。</span><br><span class="line"></span><br><span class="line">//对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）</span><br><span class="line"></span><br><span class="line">//准备就绪状态：当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行</span><br><span class="line"></span><br><span class="line">//queuePriority 属性（尽可能的并不是绝对的）决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。</span><br><span class="line">//如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。</span><br><span class="line">//如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系</span><br><span class="line"></span><br><span class="line">- (void)queuePriority&#123;</span><br><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">//    设置最大并发操作数 来控制队列的串行或者并发</span><br><span class="line">//    queue.maxConcurrentOperationCount = 1; //串行</span><br><span class="line">//        queue.maxConcurrentOperationCount = 8;//并发</span><br><span class="line">// 2.创建操作</span><br><span class="line">// 使用 NSInvocationOperation 创建操作1</span><br><span class="line">NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];</span><br><span class="line"></span><br><span class="line">// 使用 NSInvocationOperation 创建操作2</span><br><span class="line">NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];</span><br><span class="line"></span><br><span class="line">// 使用 NSInvocationOperation 创建操作2</span><br><span class="line">NSInvocationOperation *op3 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask3) object:nil];</span><br><span class="line"></span><br><span class="line">//    同一个队列中的操作优先级 执行的先后 并不是结束的先后</span><br><span class="line">//    op1.queuePriority = NSOperationQueuePriorityVeryHigh;</span><br><span class="line">//    op2.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">//    op3.queuePriority = NSOperationQueuePriorityNormal;</span><br><span class="line"></span><br><span class="line">//    服务质量  在iOS 8.0前,通过设置操作的优先级,尽可能的保证某个操作优先处理,随着硬件性能上的提升,通过设置优先级效果已经越来越不明显,在iOS 8.0后,推出了服务质量,通过设置服务质量,让系统优先处理某一个操作 目前也是越来越不明显</span><br><span class="line">//    op1.qualityOfService = NSQualityOfServiceUserInteractive;</span><br><span class="line">//    op2.qualityOfService = NSQualityOfServiceBackground;</span><br><span class="line">//    op3.qualityOfService = NSQualityOfServiceDefault;</span><br><span class="line"></span><br><span class="line">// 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start</span><br><span class="line">[queue addOperation:op2]; // [op2 start]</span><br><span class="line">[queue addOperation:op3]; // [op3 start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSOperation、NSOperationQueue 线程间的通信</span><br><span class="line">/**</span><br><span class="line">* 线程间通信</span><br><span class="line">*/</span><br><span class="line">- (void)communication &#123;</span><br><span class="line"></span><br><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line"></span><br><span class="line">// 2.添加操作</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">// 异步进行耗时操作</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到主线程</span><br><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">// 进行一些 UI 刷新等操作</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 执行的操作</span><br><span class="line">- (void)invocationTask&#123;</span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">NSLog(@&quot;invocationOperation1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)invocationTask2&#123;</span><br><span class="line">NSLog(@&quot;2&quot;);</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">NSLog(@&quot;invocationOperation2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)invocationTask3&#123;</span><br><span class="line">NSLog(@&quot;3&quot;);</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">NSLog(@&quot;invocationOperation3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">[NSThread sleepForTimeInterval:2]; // 模拟耗时操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/NSOperation、NSOperationQueue/" data-id="cjqrd1sg4000h27lbv4mlsoe0" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-UICollectionView系列一、初识与简单使用UICollectionView" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/UICollectionView系列一、初识与简单使用UICollectionView/">UICollectionView系列一、初识与简单使用UICollectionView</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/UICollectionView系列一、初识与简单使用UICollectionView/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>###一、简介<br>UICollectionView是iOS6之后引入的一个新的UI控件，它和UITableView有着诸多的相似之处，其中许多代理方法都十分类似。简单来说，UICollectionView是比UITbleView更加强大的一个UI控件，有如下几个方面：</p>
<p>1、支持水平和垂直两种方向的布局</p>
<p>2、通过layout配置方式进行布局</p>
<p>3、类似于TableView中的cell特性外，CollectionView中的Item大小和位置可以自由定义</p>
<p>4、通过layout布局回调的代理方法，可以动态的定制每个item的大小和collection的大体布局属性</p>
<p>5、更加强大一点，完全自定义一套layout布局方案，可以实现意想不到的效果</p>
<h3 id="二、先来实现一个最简单的九宫格类布局"><a href="#二、先来实现一个最简单的九宫格类布局" class="headerlink" title="二、先来实现一个最简单的九宫格类布局"></a>二、先来实现一个最简单的九宫格类布局</h3><p>在了解UICollectionView的更多属性前，我们先来使用其进行一个最简单的流布局试试看，在controller的viewDidLoad中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//创建一个layout布局类</span><br><span class="line">UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init];</span><br><span class="line">//设置布局方向为垂直流布局</span><br><span class="line">layout.scrollDirection = UICollectionViewScrollDirectionVertical;</span><br><span class="line">//设置每个item的大小为100*100</span><br><span class="line">layout.itemSize = CGSizeMake(100, 100);</span><br><span class="line">//创建collectionView 通过一个布局策略layout来创建</span><br><span class="line">UICollectionView * collect = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout];</span><br><span class="line">//代理设置</span><br><span class="line">collect.delegate=self;</span><br><span class="line">collect.dataSource=self;</span><br><span class="line">//注册item类型 这里使用系统的类型</span><br><span class="line">[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];</span><br><span class="line"></span><br><span class="line">[self.view addSubview:collect];</span><br></pre></td></tr></table></figure></p>
<p>这里有一点需要注意，collectionView在完成代理回调前，必须注册一个cell，类似如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];</span><br></pre></td></tr></table></figure></p>
<p>这和tableView有些类似，又有些不同，因为tableView除了注册cell的方法外，还可以通过临时创建来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//tableView在从复用池中取cell的时候，有如下两种方法</span><br><span class="line">//使用这种方式如果复用池中无，是可以返回nil的，我们在临时创建即可</span><br><span class="line">- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;</span><br><span class="line">//6.0后使用如下的方法直接从注册的cell类获取创建，如果没有注册 会崩溃</span><br><span class="line">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure></p>
<p>我们可以分析：因为UICollectionView是iOS6.0之前的新类，因此这里统一了从复用池中获取cell的方法，没有再提供可以返回nil的方式，并且在UICollectionView的回调代理中，只能使用从复用池中获取cell的方式进行cell的返回，其他方式会崩溃，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//这是正确的方法</span><br><span class="line">-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">UICollectionViewCell * cell  = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];</span><br><span class="line">cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];</span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这样做会崩溃</span><br><span class="line">-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">//    UICollectionViewCell * cell  = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];</span><br><span class="line">//    cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];</span><br><span class="line">UICollectionViewCell * cell = [[UICollectionViewCell alloc]init];</span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面错误的方式会崩溃，信息如下，让我们使用从复用池中取cell的方式：</p>
<p>[图片上传失败…(image-9b7f2f-1527661822069)]</p>
<p>上面的设置完成后，我们来实现如下几个代理方法：<br>这里与TableView的回调方式十分类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//返回分区个数</span><br><span class="line">-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">//返回每个分区的item个数</span><br><span class="line">-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line">//返回每个item</span><br><span class="line">-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">UICollectionViewCell * cell  = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];</span><br><span class="line">cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];</span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/4055583-cf3b28497bffd73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170628101412865.png"></p>
<p>同样，如果内容的大小超出一屏，和tableView类似是可以进行视图滑动的。</p>
<p>还有一点细节，我们在上面设置布局方式的时候设置了垂直布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout.scrollDirection = UICollectionViewScrollDirectionVertical;</span><br><span class="line">//这个是水平布局</span><br><span class="line">//layout.scrollDirection = UICollectionViewScrollDirectionHorizontal;</span><br></pre></td></tr></table></figure></p>
<p>这样系统会在一行充满后进行第二行的排列，如果设置为水平布局，则会在一列充满后，进行第二列的布局，这种方式也被称为流式布局</p>
<p>###三、UICollectionView中的常用方法和属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//通过一个布局策略初识化CollectionView</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;</span><br><span class="line"></span><br><span class="line">//获取和设置collection的layout</span><br><span class="line">@property (nonatomic, strong) UICollectionViewLayout *collectionViewLayout;</span><br><span class="line"></span><br><span class="line">//数据源和代理</span><br><span class="line">@property (nonatomic, weak, nullable) id &lt;UICollectionViewDelegate&gt; delegate;</span><br><span class="line">@property (nonatomic, weak, nullable) id &lt;UICollectionViewDataSource&gt; dataSource;</span><br><span class="line"></span><br><span class="line">//从一个class或者xib文件进行cell(item)的注册</span><br><span class="line">- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;</span><br><span class="line">- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;</span><br><span class="line"></span><br><span class="line">//下面两个方法与上面相似，这里注册的是头视图或者尾视图的类</span><br><span class="line">//其中第二个参数是设置 头视图或者尾视图 系统为我们定义好了这两个字符串</span><br><span class="line">//UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);</span><br><span class="line">//UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);</span><br><span class="line">- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;</span><br><span class="line">- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;</span><br><span class="line"></span><br><span class="line">//这两个方法是从复用池中取出cell或者头尾视图</span><br><span class="line">- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//设置是否允许选中 默认yes</span><br><span class="line">@property (nonatomic) BOOL allowsSelection;</span><br><span class="line"></span><br><span class="line">//设置是否允许多选 默认no</span><br><span class="line">@property (nonatomic) BOOL allowsMultipleSelection;</span><br><span class="line"></span><br><span class="line">//获取所有选中的item的位置信息</span><br><span class="line">- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForSelectedItems; </span><br><span class="line"></span><br><span class="line">//设置选中某一item，并使视图滑动到相应位置，scrollPosition是滑动位置的相关参数，如下：</span><br><span class="line">/*</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123;</span><br><span class="line">//无</span><br><span class="line">UICollectionViewScrollPositionNone                 = 0,</span><br><span class="line">//垂直布局时使用的 对应上中下</span><br><span class="line">UICollectionViewScrollPositionTop                  = 1 &lt;&lt; 0,</span><br><span class="line">UICollectionViewScrollPositionCenteredVertically   = 1 &lt;&lt; 1,</span><br><span class="line">UICollectionViewScrollPositionBottom               = 1 &lt;&lt; 2,</span><br><span class="line">//水平布局时使用的  对应左中右</span><br><span class="line">UICollectionViewScrollPositionLeft                 = 1 &lt;&lt; 3,</span><br><span class="line">UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4,</span><br><span class="line">UICollectionViewScrollPositionRight                = 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">- (void)selectItemAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UICollectionViewScrollPosition)scrollPosition;</span><br><span class="line"></span><br><span class="line">//将某一item取消选中</span><br><span class="line">- (void)deselectItemAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">//重新加载数据</span><br><span class="line">- (void)reloadData;</span><br><span class="line"></span><br><span class="line">//下面这两个方法，可以重新设置collection的布局，后面的方法多了一个布局完成后的回调，iOS7后可以用</span><br><span class="line">//使用这两个方法可以产生非常炫酷的动画效果</span><br><span class="line">- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated;</span><br><span class="line">- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);</span><br><span class="line"></span><br><span class="line">//下面这些方法更加强大，我们可以对布局更改后的动画进行设置</span><br><span class="line">//这个方法传入一个布局策略layout，系统会开始进行布局渲染，返回一个UICollectionViewTransitionLayout对象</span><br><span class="line">//这个UICollectionViewTransitionLayout对象管理动画的相关属性，我们可以进行设置</span><br><span class="line">- (UICollectionViewTransitionLayout *)startInteractiveTransitionToCollectionViewLayout:(UICollectionViewLayout *)layout completion:(nullable UICollectionViewLayoutInteractiveTransitionCompletion)completion NS_AVAILABLE_IOS(7_0);</span><br><span class="line">//准备好动画设置后，我们需要调用下面的方法进行布局动画的展示，之后会调用上面方法的block回调</span><br><span class="line">- (void)finishInteractiveTransition NS_AVAILABLE_IOS(7_0);</span><br><span class="line">//调用这个方法取消上面的布局动画设置，之后也会进行上面方法的block回调</span><br><span class="line">- (void)cancelInteractiveTransition NS_AVAILABLE_IOS(7_0);</span><br><span class="line"></span><br><span class="line">//获取分区数</span><br><span class="line">- (NSInteger)numberOfSections;</span><br><span class="line"></span><br><span class="line">//获取某一分区的item数</span><br><span class="line">- (NSInteger)numberOfItemsInSection:(NSInteger)section;</span><br><span class="line"></span><br><span class="line">//下面两个方法获取item或者头尾视图的layout属性，这个UICollectionViewLayoutAttributes对象</span><br><span class="line">//存放着布局的相关数据，可以用来做完全自定义布局，后面博客会介绍</span><br><span class="line">- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//获取某一点所在的indexpath位置</span><br><span class="line">- (nullable NSIndexPath *)indexPathForItemAtPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">//获取某个cell所在的indexPath</span><br><span class="line">- (nullable NSIndexPath *)indexPathForCell:(UICollectionViewCell *)cell;</span><br><span class="line"></span><br><span class="line">//根据indexPath获取cell</span><br><span class="line">- (nullable UICollectionViewCell *)cellForItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//获取所有可见cell的数组</span><br><span class="line">- (NSArray&lt;__kindof UICollectionViewCell *&gt; *)visibleCells;</span><br><span class="line"></span><br><span class="line">//获取所有可见cell的位置数组</span><br><span class="line">- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleItems;</span><br><span class="line"></span><br><span class="line">//下面三个方法是iOS9中新添加的方法，用于获取头尾视图</span><br><span class="line">- (UICollectionReusableView *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (NSArray&lt;UICollectionReusableView *&gt; *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line">//使视图滑动到某一位置，可以带动画效果</span><br><span class="line">- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">//下面这些方法用于动态添加，删除，移动某些分区获取items</span><br><span class="line">- (void)insertSections:(NSIndexSet *)sections;</span><br><span class="line">- (void)deleteSections:(NSIndexSet *)sections;</span><br><span class="line">- (void)reloadSections:(NSIndexSet *)sections;</span><br><span class="line">- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;</span><br><span class="line"></span><br><span class="line">- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;</span><br><span class="line">- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;</span><br><span class="line">- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;</span><br><span class="line">- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/UICollectionView系列一、初识与简单使用UICollectionView/" data-id="cjqrd1sg4000i27lbz32p5q01" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-UICollectionView系列六——将布局从平面应用到空间" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/10/UICollectionView系列六——将布局从平面应用到空间/">UICollectionView系列六——将布局从平面应用到空间</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/01/10/UICollectionView系列六——将布局从平面应用到空间/" class="article-date">
  <time datetime="2019-01-10T02:30:28.042Z" itemprop="datePublished">2019-01-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>前面，我们将布局由线性的瀑布流布局扩展到了圆环布局，这使我们使用UICollectionView的布局思路大大迈进了一步，这次，我们玩的更加炫一些，想办法将布局应用到空间。之前在管理布局的item的具体属性的类UICollectionViewLayoutAttributrs类中，有transform3D这个属性，通过这个属性的设置，我们真的可以在空间的坐标系中进行布局设计。iOS系统的控件中，也并非没有这样的先例，UIPickerView就是很好的一个实例，这篇博客，我们就通过使用UICollectionView实现一个类似系统的UIPickerView的布局视图，来体会UICollectionView在3D控件布局的魅力。系统的pickerView效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4055583-1d06336b95163ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="61.png"></p>
<h3 id="二、先来实现一个炫酷的滚轮空间布局"><a href="#二、先来实现一个炫酷的滚轮空间布局" class="headerlink" title="二、先来实现一个炫酷的滚轮空间布局"></a>二、先来实现一个炫酷的滚轮空间布局</h3><p>万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface MyLayout : UICollectionViewLayout</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。</p>
<p>至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。</p>
<p>在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">MyLayout * layout = [[MyLayout alloc]init];</span><br><span class="line">UICollectionView * collect  = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];</span><br><span class="line">collect.delegate=self;</span><br><span class="line">collect.dataSource=self;</span><br><span class="line">[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];</span><br><span class="line">[self.view addSubview:collect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line">-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">UICollectionViewCell * cell  = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];</span><br><span class="line">cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];</span><br><span class="line">UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)];</span><br><span class="line">label.text = [NSString stringWithFormat:@&quot;我是第%ld行&quot;,(long)indexPath.row];</span><br><span class="line">[cell.contentView addSubview:label];</span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。</p>
<p>在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;</span><br><span class="line">NSMutableArray * attributes = [[NSMutableArray alloc]init];</span><br><span class="line">//遍历设置每个item的布局属性</span><br><span class="line">for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123;</span><br><span class="line">[attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]];</span><br><span class="line">&#125;</span><br><span class="line">return attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">//创建一个item布局属性类</span><br><span class="line">UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];</span><br><span class="line">//获取item的个数</span><br><span class="line">int itemCounts = (int)[self.collectionView numberOfItemsInSection:0];</span><br><span class="line">//设置每个item的大小为260*100</span><br><span class="line">atti.size = CGSizeMake(260, 100);  </span><br><span class="line">/*</span><br><span class="line">后边介绍的代码添加在这里</span><br><span class="line"></span><br><span class="line">*/ </span><br><span class="line">return atti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。</p>
<p>首先，我们先将所有的item的位置都设置为collectionView的中心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2);</span><br></pre></td></tr></table></figure></p>
<p>这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下：<br><img src="https://upload-images.jianshu.io/upload_images/4055583-d1467248044560c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="62.png"></p>
<p>很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建一个transform3D类</span><br><span class="line">//CATransform3D是一个类似矩阵的结构体</span><br><span class="line">//CATransform3DIdentity创建空得矩阵</span><br><span class="line">CATransform3D trans3D = CATransform3DIdentity;</span><br><span class="line">//这个值设置的是透视度，影响视觉离投影平面的距离</span><br><span class="line">trans3D.m34 = -1/900.0;</span><br><span class="line">//下面这些属性 后面会具体介绍</span><br><span class="line">//这个是3D滚轮的半径</span><br><span class="line">CGFloat radius = 50/tanf(M_PI*2/itemCounts/2);</span><br><span class="line">//计算每个item应该旋转的角度</span><br><span class="line">CGFloat angle = (float)(indexPath.row)/itemCounts*M_PI*2;</span><br><span class="line">//这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加</span><br><span class="line">//第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转</span><br><span class="line">trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0);</span><br><span class="line">//进行设置</span><br><span class="line">atti.transform3D = trans3D;</span><br></pre></td></tr></table></figure></p>
<p> 对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4055583-7ef288d70d31e8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="63.png"></p>
<p> 通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 </p>
<p> 对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4055583-fa8e2ad1c5f2c8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="64.png"></p>
<p> 每个item旋转的弧度就是其索引/(2*pi)。</p>
<p> 通过上面的设置，我们再运行代码，效果如下：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4055583-dcad16e7d7055fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="65.png"></p>
<p> 仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4055583-0e62e965fa68b833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="66.png"></p>
<p> 我们继续在刚才的代码后面添加这行代码：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移</span><br><span class="line"> trans3D = CATransform3DTranslate(trans3D, 0, 0, radius);</span><br></pre></td></tr></table></figure></p>
<p> 再次运行，效果如下：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4055583-3ca999f52e419d7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="67.png"></p>
<p> 布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。</p>
<h3 id="三、让滚轮滑动起来"><a href="#三、让滚轮滑动起来" class="headerlink" title="三、让滚轮滑动起来"></a>三、让滚轮滑动起来</h3><p> 通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果</p>
<p> 首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> -(CGSize)collectionViewContentSize&#123;</span><br><span class="line"> return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> //返回yes，则一有变化就会刷新布局</span><br><span class="line"> -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123;</span><br><span class="line"> return YES;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 将上面的布局的中心点设置加上一个动态的偏移量：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y);</span><br></pre></td></tr></table></figure></p>
<p> 现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> //获取当前的偏移量</span><br><span class="line"> float offset = self.collectionView.contentOffset.y;</span><br><span class="line"> //在角度设置上，添加一个偏移角度</span><br><span class="line"> float angleOffset = offset/self.collectionView.frame.size.height;</span><br><span class="line"> CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts*M_PI*2;</span><br></pre></td></tr></table></figure></p>
<p> 再看看效果，没错，就是这么简单，滚轮已经转了起来。</p>
<h3 id="四、让其循环滚动的逻辑"><a href="#四、让其循环滚动的逻辑" class="headerlink" title="四、让其循环滚动的逻辑"></a>四、让其循环滚动的逻辑</h3><p> 我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> -(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;</span><br><span class="line"> //小于半屏 则放到最后一屏多半屏</span><br><span class="line"> if (scrollView.contentOffset.y&lt;200) &#123;</span><br><span class="line"> scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10*400);</span><br><span class="line"> //大于最后一屏多一屏 放回第一屏</span><br><span class="line"> &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123;</span><br><span class="line"> scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10*400);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配：</p>
<p> 在viewController中：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //一开始将collectionView的偏移量设置为1屏的偏移量</span><br><span class="line"> collect.contentOffset = CGPointMake(0, 400);</span><br></pre></td></tr></table></figure></p>
<p> 在layout类中：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //将滚动范围设置为(item总数+2)*每屏高度 </span><br><span class="line"> -(CGSize)collectionViewContentSize&#123;</span><br><span class="line"> return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //将计算的具体item角度向前递推一个</span><br><span class="line"> CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts*M_PI*2;</span><br></pre></td></tr></table></figure>
<p> OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！</p>
<p> <a href="http://pan.baidu.com/s/1jGCmbKM" target="_blank" rel="noopener">http://pan.baidu.com/s/1jGCmbKM</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/UICollectionView系列六——将布局从平面应用到空间/" data-id="cjqrd1sg5000j27lbmbfzf1s9" class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

</article>



      
  </article>
  
  
    <nav class="page-nav">
      
      <a class="extend prev" rel="prev" href="/">前一篇</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 悠悠我心</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <!--
      <li><a href="/">悠悠我心</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="悠悠我心"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>