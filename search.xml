<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 添加票据到wallet]]></title>
    <url>%2F2019%2F01%2F11%2FsaveToWallet%2F</url>
    <content type="text"><![CDATA[wallet的前身为passbook，2015年WWDC大会苹果正式改名wallet，passbook是苹果2012年iOS6开放出来的新功能.可以帮助用户管理五种类型（Boarding passes（登机牌），Coupons（优惠券），Store cards（购物卡），Event tickets（入场券），Generic（通用卡））的票据 在iOS中一个Pass其实就是一个.pkpass文件，事实上它是一个Zip压缩包，只是这个压缩包要按照一定的目录结构来设计如何创建一个Pass可以参考Apple的文档https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/YourFirst.html#//apple_ref/doc/uid/TP40012195-CH2-SW1 12345678910111213141516171819202122232425262728293031323334353637383940414243-(void)addPassbookView:(NSData *)date&#123; NSError *error = nil; BOOL passEnbale = [PKPassLibrary isPassLibraryAvailable];//检查pass是否可用 if (![PKPassLibrary isPassLibraryAvailable]) &#123;// dispatch_async(dispatch_get_main_queue(), ^&#123; //[[WaitDialogFullS sharedWaitDialog] endLoading]; [[[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;PassKit not available&quot; delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles: nil] show]; &#125;); return; &#125; if (passEnbale) &#123; PKPass *onePass = [[PKPass alloc] initWithData:date error:&amp;error]; if (error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; ZNLog(@&quot;!!!!!ERROR:%@&quot;,[error description]); UIAlertView *alert = [[UIAlertView alloc]initWithTitle:GDLocalizedString(@&quot;jpyd_Friendlyreminder&quot;) message:GDLocalizedString(@&quot;sy_onePass&quot;) delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles:nil, nil]; [alert show]; [alert release]; &#125;); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; PKAddPassesViewController *passAddViewController = [[[PKAddPassesViewController alloc] initWithPass:onePass]autorelease]; passAddViewController.delegate = self; ChinaEastViewController *app = [ChinaEastViewController sharedBankcommViewController]; //Application tried to present a nil modal view controller on target .修改听云，李良 if (passAddViewController) &#123; [app presentViewController:passAddViewController animated:YES completion:^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; &#125;]; &#125; &#125;); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CADisplayLink小知识点获得FPS]]></title>
    <url>%2F2019%2F01%2F10%2FCADisplayLink%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%8E%B7%E5%BE%97FPS%2F</url>
    <content type="text"><![CDATA[###CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类. iPhone设备的屏幕刷新是60Hz，即一秒60次。 123456789101112131415161718//CADisplayLinkCADisplayLink * timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];[_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];- (void)tick:(CADisplayLink *)link &#123;if (_lastTime == 0) &#123;//上一次屏幕刷新的时间_lastTime = link.timestamp;//屏幕刷新的时间戳return;&#125;_count++;//刷新次数NSTimeInterval delta = link.timestamp - _lastTime;//获得两次刷新的时间间隔if (delta &lt; 1) return;//间隔1秒_lastTime = link.timestamp;float fps = _count / delta;//fps = 次数/时间间隔_count = 0;//置零 重新计算&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用解决办法]]></title>
    <url>%2F2019%2F01%2F10%2FMac%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、命令 lsof -i tcp:port （port替换成端口号，比如8081）可以查看该端口被什么程序占用，并显示pid，方便KILL 2、使用kill -9 + pid 3、重启xcode]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift String和NSDate的相互转化]]></title>
    <url>%2F2019%2F01%2F10%2FSwift%20%20String%E5%92%8CNSDate%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[####1.String 转化成 NSDate :通常我在提交数据的时候时间格式都是14位,例如:”20161224191234”, 为了开发方便,需要把字符串转化成 NSDatelet dateString = “20161224191234” let formatter = NSDateFormatter()formatter.dateFormat = “yyyyMMddHHmmss”formatter.dateFromString(dateString) 这里的 dateFormat 格式要跟你自己的日期字符串格式一样, HH 为24小时制须大写,如不大写,上面转换出来结果为 nil. ####2.NSDate 转化成 String var normalTime:String{ let formatter = NSDateFormatter() formatter.dateFormat = “yyyy-MM-dd HH:mm:ss” return formatter.stringFromDate(NSDate()) } 这样结果就是2016-12-24 19:12:34的格式,格式由自己需求来定 ####3.由日期判断是星期几 扩展 NSDate,写一个方法 extension NSDate{ func resultWeek()-&gt;Int{ let interval = self.timeIntervalSince1970 let day = Int(interval/86400) return (day-3)%7 } } 上面的&quot;20161224191234&quot;判断一下是周几 let weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;] let week = weeks[formatter.dateFromString(dateString)!.resultWeek()] 结果是星期六 ####4.判断两个日期时间差 let firstDate = &quot;2016-09-24&quot; let secondDate = &quot;2016-12-24&quot; let cformatter = NSDateFormatter() cformatter.dateFormat = &quot;yyyy-MM-dd&quot; let sDate = cformatter.dateFromString(firstDate) let cDate = cformatter.dateFromString(secondDate) let intervals = cDate?.timeIntervalSinceDate(sDate!) //时间差(单位是秒) let day_seconds = 24*3600 //一天的秒数 let days = Int(intervals!)/day_seconds //结果就是两个日期的时间差(单位是天)]]></content>
  </entry>
  <entry>
    <title><![CDATA[TCP与UDP区别]]></title>
    <url>%2F2019%2F01%2F10%2FTCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 UDP补充：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。 TCP补充：TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[今天是个人博客开通的第一天，搞了半天终于好了，好激动！！！以前自己做的学习记录有在本地文件的，有在备忘录的，有在简书的。。。反正就是各种地方，很多慢慢都找不到了。这次正好最近闲下来整理下。慢慢的都放到自己的博客中。 我有一头小毛驴，可是我从来都不骑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 协议中定义属性]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1234@protocol CETableViewModelProtocol &lt;NSObject&gt;@property (nonatomic, strong) Class cellClass;@property (nonatomic, copy ) NSString* cellType;@end 协议中是可以定义属性的，但是只有对应的getter和setter方法 但是没有对应的成员变量 而getter和setter就是操作的对应成员变量 所以就无法调用getter或者setter 否则项目崩溃 想要调用的话 需要在实现这个协议的类中用@synthesize cellType = _cellType;来声明成员变量,这样这个类的对象就拥有了协议中定义的这些属性，用法跟自身其他属性一样就不啰嗦了。 来看看实例吧： .h123456789#import &lt;Foundation/Foundation.h&gt;#import &quot;CETableViewModelProtocol.h&quot;NS_ASSUME_NONNULL_BEGIN@interface CETableViewModel : NSObject &lt;CETableViewModelProtocol&gt;@endNS_ASSUME_NONNULL_END .m 123456#import &quot;CETableViewModel.h&quot;@implementation CETableViewModel@synthesize cellHeight = _cellHeight;@synthesize cellType = _cellType;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 宏(define)与常量(const)以及extern]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%20%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)%E4%BB%A5%E5%8F%8Aextern%2F</url>
    <content type="text"><![CDATA[###思考下，下面的有什么不同，分别在什么时候使用呢？12345678910#define HSCoder @&quot;汉斯哈哈哈&quot;NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;extern NSString *HSCoder;extern const NSString *HSCoder;static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;; ###当我们想全局共用一些数据时，可以用宏、变量、常量 宏：1#define HSCoder @&quot;汉斯哈哈哈&quot; 变量：1NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; 常量：12345四种写法：static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;; 宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大 变量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段会执行类型检查 常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查 ###const和static const区分1234const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; //本文件内部的全局常量static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//用static修饰后，不能提供外界访问,只能在本文件内访问,或者导入本文件可用（iOS中只有.h文件的导入，所以定义在.h中，如果导入.h头文件那么外部也可以用，如果定义在.m则只能在.m本文件内部使用） ###const修饰位置const右边的总不能被修改123456781.const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改2.NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改3.NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;HSCoder&quot;不能被修改，&quot;*HSCoder&quot;能被修改 “static作用”: 修饰局部变量： 1.延长局部变量的生命周期,程序结束才会销毁。 2.局部变量只会生成一份内存,只会初始化一次。 3.改变局部变量的作用域。 修饰全局变量 1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改 2.避免重复定义全局变量 ####const作用：限制类型 1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p） 2.被const修饰的变量是只读的。 ####”extern作用”: 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 “extern工作原理”: 先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 知识补充：对于指针a来说，*a就是指针a所指向的内存空间存储的值,&amp;a就是存储这个变量的内存地址,a是指针名 staic和const联合的作用:声明一个静态的全局只读常量,在”一个文件中”经常使用的字符串常量，可以使用static与const组合 extern与const组合的作用：在”多个文件中”经常使用的同一个字符串常量，可以使用extern与const组合。 static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合:只需要定义一份全局变量，多个文件共享]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS中的@synthesize]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%B8%AD%E7%9A%84%40synthesize%2F</url>
    <content type="text"><![CDATA[常见的有两种用法 其实是一个意思 @synthesize student; 等价于 @synthesize student = student @synthesize student = _student ARC下 通过@property声明的属性，编译器会自动声明对应的成员变量和getter/setter方法 而@synthesize student = _student就是程序猿自己显式地声明属性对应的成员变量，而不用编译器自生成的我们知道getter和setter方法里面操作的其实就是属性对应的成员变量 成员变量其实本质上就是一个变量指针 那么调用两者有什么区别呢？12self.name = @&quot;我信你个鬼&quot;;_name = @&quot;我信你个大头鬼&quot;; self.name本质上是调用的setter方法setName() 而setter方法是依赖于@property的属性修饰符的，比如retain，assign等属性。也就是会影响其引用计数 而_name = @”我信你个大头鬼” 只是变量的赋值 不涉及retain、assign等]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS保存图片到相册]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[需要导入系统框架 #import &lt;Photos/Photos.h&gt; 然后我们直接上代码 123456789101112131415161718192021- (void)clickQRCode:(UIImage *)image&#123;[MBProgressHUD HUDForView:self.view];[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;[PHAssetChangeRequest creationRequestForAssetFromImage:image];&lt;!-- more --&gt;&#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123;NSLog(@&quot;success = %d, error = %@&quot;, success, error);dispatch_async(dispatch_get_main_queue(), ^&#123;[MBProgressHUD hideHUDForView:self.view];if (success) &#123;[MBProgressHUD showSuccess:@&quot;保存成功&quot; toView:self.view];&#125;else&#123;UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;请在“设置-隐私”中允许空能净访问您的照片&quot; message:nil delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil];[alert show];&#125;&#125;);&#125;];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS之创建一个常驻线程]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%B9%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[常驻线程有什么用呢？让一个一直存在的子线程，等待其他线程发来消息，处理其他事件。 注意 ：不要使用GCD的global队列创建常驻线程原因：global全局队列，整个工程共用的队列，队列里的所有线程都会放进一个线程池中，当线程池满了的时候，就会进入等待 状态，后面加进来的block就不会创建新的线程执行了 等待前面的任务执行完成，才会继续执行。如果线程池中的线程长时间不结束，后续堆积的任务会越来越多12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@interface LongThreadDemoController ()@property (nonatomic, strong) NSThread *thread;@end@implementation LongThreadDemoController- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor whiteColor];self.title = @&quot;常驻线程Demo&quot;;&#125;- (void)threadRunloopPoint:(id)__unused object&#123;NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));@autoreleasepool &#123;[[NSThread currentThread] setName:@&quot;changzhuThread&quot;];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];//// 这里主要是监听某个 port，目的是让这个 Thread 不会回收[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];&#125;&#125;- (NSThread *)thread&#123;if(!_thread)&#123;_thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadRunloopPoint:) object:nil];[_thread start];&#125;return _thread;&#125;- (void)test&#123;NSLog(@&quot;%s&quot;,__func__);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;[self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS图片拉伸]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E5%9B%BE%E7%89%87%E6%8B%89%E4%BC%B8%2F</url>
    <content type="text"><![CDATA[123UIImage * img = [UIImage imageNamed:@&quot;3X&quot;];float w = img.size.width;float h = img.size.height; 123456789//图片拉伸 当imgview的frame跟img不一样大时就会拉伸图片来填充//第一个参数 UIEdgeInsets 是规定上下左右到img边的部分不拉伸受到保护 中间部分进行拉伸//UIImageResizingModeStretch 拉伸//UIImageResizingModeTile 平铺UIImage * newImg = [img resizableImageWithCapInsets:UIEdgeInsetsMake(h * 0.5, w * 0.5, h * 0.5, w * 0.5) resizingMode:UIImageResizingModeStretch];]]></content>
  </entry>
  <entry>
    <title><![CDATA[tableviewcell注册和不注册的区别及用法]]></title>
    <url>%2F2019%2F01%2F10%2Ftableviewcell%E6%B3%A8%E5%86%8C%E5%92%8C%E4%B8%8D%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注册和不注册的区别主要看下面这两个方法： 1234567- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.(返回给代理一个已经分配的cell，代替一个新的cell，如果没有已分配的cell，则返回nil，使用这个方法就不需要注册了)- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 如果cell的identifier是注册过的，那么这个新列出的方法保证返回一个cell (有分配的就返回已分配的cell，没有返回新的cell)并适当调整大小，可省略cell空值判断步骤，用这个方法cell必须注册,不是自定义的cell，UITableViewCell也要注册]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决Mac和iOS模拟器间拷贝粘贴的问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E8%A7%A3%E5%86%B3Mac%E5%92%8CiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%97%B4%E6%8B%B7%E8%B4%9D%E7%B2%98%E8%B4%B4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、检查模拟器的Edit &gt; Automatically Sync Pasteboard是否勾选 如果失效了可以关闭再打开试试2、按照上述操作还不行的,注意 HardWare =&gt; keyboard =&gt; send menu keyboard … 处于勾选状态~]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码修改xib约束的值注意]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9xib%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%80%BC%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[有时候在初始化中或者viewdidload中直接改变top.constant的值没有用，可能是因为代码设置后 xib后更新（xib加载在代码设置后） 这个时候使用延迟加载即可 1234[self performSelector:@selector(modifyConstant) withObject:nil afterDelay:0.1];//延迟加载,执行- (void)modifyConstant&#123;self.topSafeH.constant += 100;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[NSOperation、NSOperationQueue]]></title>
    <url>%2F2019%2F01%2F10%2FNSOperation%E3%80%81NSOperationQueue%2F</url>
    <content type="text"><![CDATA[####一、 为什么要使用 NSOperation、NSOperationQueueNSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。可添加完成的代码块，在操作完成后执行。添加操作之间的依赖关系，方便的控制执行顺序。 设定操作执行的优先级。可以很方便的取消一个操作的执行。使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 ####二、同步异步以及并行串行的区别同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态并行串行是指有多个线程的任务的执行方式，串行则多个任务按顺序执行，并行则多个任务会同时执行 三、 NSOperation 实现多线程的使用步骤分为三步：NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 1、创建操作：先将需要执行的操作封装到一个NSOperation 对象中。2、创建队列：创建NSOperationQueue对象。3、将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 ####四、线程死锁12345// NSLog(@&quot;1&quot;);// dispatch_sync(dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;2&quot;);// &#125;);// NSLog(@&quot;3&quot;); 主线程是串行队列, 一个任务执行完成才能往下执行, 同步线程是一个任务A ,里面的block是同步线程插入到当前线程的另一个任务B ,A要等B执行完才返回 ,B要等A执行完才能执行 ,会相互等待 造成死锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.// 创建操作// [self useInvocationOperation];//// NSOperation单独使用 同步执行 等待结果返回后执行后面语句// NSLog(@&quot;下一个语句&quot;);// [self useBlockOperation];// 创建队列// [self addOperationToQueue];// 添加依赖// [self addDependency];// 优先级// [self queuePriority];// 线程间通讯// [self communication];// 线程死锁：主线程是串行队列 一个任务执行完成才能往下执行 同步线程是一个任务A 里面的block是同步线程插入到当前线程的另一个任务B A要等B执行完才返回 B要等A执行完才能执行 会相互等待 造成死锁// NSLog(@&quot;1&quot;);// dispatch_sync(dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;2&quot;);// &#125;);// NSLog(@&quot;3&quot;);&#125;#pragma mark - 创建操作//NSOperation 单独使用时系统同步执行操作//NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。//使用子类 NSInvocationOperation//使用子类 NSBlockOperation//自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。- (void)useInvocationOperation&#123;NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 开始操作[invocationOperation start];&#125;//NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行(完成顺序是不一定的)。只有当所有相关的操作已经完成执行时，才视为完成//一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。- (void)useBlockOperation&#123;NSBlockOperation * blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;blockOperation---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 2.添加额外的操作[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 调用 start 方法开始执行操作[blockOperation start];&#125;- (void)useCustomOperation&#123;&#125;#pragma mark - 创建队列//NSOperationQueue 创建的自定义队列同时具有串行、并发功能，通过设置属性maxConcurrentOperationCount（最大并发操作数）用来控制一个特定队列中可以有多少个操作同时参与并发执行。//当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理//那么我们需要将创建好的操作加入到队列中去。总共有两种方法：//1、- (void)addOperation:(NSOperation *)op;//2、- (void)addOperationWithBlock:(void (^)(void))block;/*** 使用 addOperation: 将操作加入到操作队列中*/- (void)addOperationToQueue &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 设置最大并发操作数 来控制队列的串行或者并发queue.maxConcurrentOperationCount = 1;// queue.maxConcurrentOperationCount = 8;// 2.创建操作// 使用 NSInvocationOperation 创建操作1NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];op1.queuePriority = NSOperationQueuePriorityHigh;op2.queuePriority = NSOperationQueuePriorityLow;// 使用 NSBlockOperation 创建操作3NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[op3 addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 3.使用 addOperation: 添加所有操作到队列中[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start[queue addOperation:op2]; // [op2 start][queue addOperation:op3]; // [op3 start]&#125;/*** 使用 addOperationWithBlock: 将操作加入到操作队列中无需自己创建操作对象 直接将操作放到block中*/- (void)addOperationWithBlockToQueue &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.使用 addOperationWithBlock: 添加操作到队列中[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];&#125;#pragma mark - NSOperation 操作依赖//NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。//- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。//- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。//@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。- (void)addDependency &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.创建操作NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 3.添加依赖[op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2// 4.添加操作到队列中[queue addOperation:op1];[queue addOperation:op2];&#125;#pragma mark - NSOperation 优先级 &amp; 服务质量（只是尽可能的 并不是绝对的）//NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。//对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）//准备就绪状态：当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行//queuePriority 属性（尽可能的并不是绝对的）决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。//如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。//如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系- (void)queuePriority&#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 设置最大并发操作数 来控制队列的串行或者并发// queue.maxConcurrentOperationCount = 1; //串行// queue.maxConcurrentOperationCount = 8;//并发// 2.创建操作// 使用 NSInvocationOperation 创建操作1NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op3 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask3) object:nil];// 同一个队列中的操作优先级 执行的先后 并不是结束的先后// op1.queuePriority = NSOperationQueuePriorityVeryHigh;// op2.queuePriority = NSOperationQueuePriorityHigh;// op3.queuePriority = NSOperationQueuePriorityNormal;// 服务质量 在iOS 8.0前,通过设置操作的优先级,尽可能的保证某个操作优先处理,随着硬件性能上的提升,通过设置优先级效果已经越来越不明显,在iOS 8.0后,推出了服务质量,通过设置服务质量,让系统优先处理某一个操作 目前也是越来越不明显// op1.qualityOfService = NSQualityOfServiceUserInteractive;// op2.qualityOfService = NSQualityOfServiceBackground;// op3.qualityOfService = NSQualityOfServiceDefault;// 3.使用 addOperation: 添加所有操作到队列中[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start[queue addOperation:op2]; // [op2 start][queue addOperation:op3]; // [op3 start]&#125;#pragma mark - NSOperation、NSOperationQueue 线程间的通信/*** 线程间通信*/- (void)communication &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];// 2.添加操作[queue addOperationWithBlock:^&#123;// 异步进行耗时操作for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;// 回到主线程[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;// 进行一些 UI 刷新等操作for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];&#125;];&#125;#pragma mark - 执行的操作- (void)invocationTask&#123;NSLog(@&quot;1&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation1---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;- (void)invocationTask2&#123;NSLog(@&quot;2&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation2---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;- (void)invocationTask3&#123;NSLog(@&quot;3&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation3---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;@end]]></content>
  </entry>
</search>
