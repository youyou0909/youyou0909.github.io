<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F11%2FsaveToWallet%2F</url>
    <content type="text"><![CDATA[iOS 添加票据到walletwallet的前身为passbook，2015年WWDC大会苹果正式改名wallet，passbook是苹果2012年iOS6开放出来的新功能.可以帮助用户管理五种类型（Boarding passes（登机牌），Coupons（优惠券），Store cards（购物卡），Event tickets（入场券），Generic（通用卡））的票据 在iOS中一个Pass其实就是一个.pkpass文件，事实上它是一个Zip压缩包，只是这个压缩包要按照一定的目录结构来设计如何创建一个Pass可以参考Apple的文档https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/YourFirst.html#//apple_ref/doc/uid/TP40012195-CH2-SW1 12345678910111213141516171819202122232425262728293031323334353637383940414243-(void)addPassbookView:(NSData *)date&#123; NSError *error = nil; BOOL passEnbale = [PKPassLibrary isPassLibraryAvailable];//检查pass是否可用 if (![PKPassLibrary isPassLibraryAvailable]) &#123;// dispatch_async(dispatch_get_main_queue(), ^&#123; //[[WaitDialogFullS sharedWaitDialog] endLoading]; [[[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;PassKit not available&quot; delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles: nil] show]; &#125;); return; &#125; if (passEnbale) &#123; PKPass *onePass = [[PKPass alloc] initWithData:date error:&amp;error]; if (error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; ZNLog(@&quot;!!!!!ERROR:%@&quot;,[error description]); UIAlertView *alert = [[UIAlertView alloc]initWithTitle:GDLocalizedString(@&quot;jpyd_Friendlyreminder&quot;) message:GDLocalizedString(@&quot;sy_onePass&quot;) delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles:nil, nil]; [alert show]; [alert release]; &#125;); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; PKAddPassesViewController *passAddViewController = [[[PKAddPassesViewController alloc] initWithPass:onePass]autorelease]; passAddViewController.delegate = self; ChinaEastViewController *app = [ChinaEastViewController sharedBankcommViewController]; //Application tried to present a nil modal view controller on target .修改听云，李良 if (passAddViewController) &#123; [app presentViewController:passAddViewController animated:YES completion:^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; &#125;]; &#125; &#125;); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CADisplayLink小知识点获得FPS]]></title>
    <url>%2F2019%2F01%2F10%2FCADisplayLink%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%8E%B7%E5%BE%97FPS%2F</url>
    <content type="text"><![CDATA[###CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类. iPhone设备的屏幕刷新是60Hz，即一秒60次。1234567891011121314151617181920//CADisplayLinkCADisplayLink * timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];[_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];- (void)tick:(CADisplayLink *)link &#123;if (_lastTime == 0) &#123;//上一次屏幕刷新的时间_lastTime = link.timestamp;//屏幕刷新的时间戳return;&#125;_count++;//刷新次数NSTimeInterval delta = link.timestamp - _lastTime;//获得两次刷新的时间间隔if (delta &lt; 1) return;//间隔1秒_lastTime = link.timestamp;float fps = _count / delta;//fps = 次数/时间间隔_count = 0;//置零 重新计算&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用解决办法]]></title>
    <url>%2F2019%2F01%2F10%2FMac%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、命令 lsof -i tcp:port （port替换成端口号，比如8081）可以查看该端口被什么程序占用，并显示pid，方便KILL 2、使用kill -9 + pid 3、重启xcode]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift String和NSDate的相互转化]]></title>
    <url>%2F2019%2F01%2F10%2FSwift%20%20String%E5%92%8CNSDate%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[####1.String 转化成 NSDate :通常我在提交数据的时候时间格式都是14位,例如:”20161224191234”, 为了开发方便,需要把字符串转化成 NSDate let dateString = “20161224191234”let formatter = NSDateFormatter()formatter.dateFormat = “yyyyMMddHHmmss”formatter.dateFromString(dateString) 这里的 dateFormat 格式要跟你自己的日期字符串格式一样, HH 为24小时制须大写,如不大写,上面转换出来结果为 nil. ####2.NSDate 转化成 String var normalTime:String{ let formatter = NSDateFormatter() formatter.dateFormat = “yyyy-MM-dd HH:mm:ss” return formatter.stringFromDate(NSDate()) } 这样结果就是2016-12-24 19:12:34的格式,格式由自己需求来定 ####3.由日期判断是星期几 扩展 NSDate,写一个方法 extension NSDate{ func resultWeek()-&gt;Int{ let interval = self.timeIntervalSince1970 let day = Int(interval/86400) return (day-3)%7 } } 上面的&quot;20161224191234&quot;判断一下是周几 let weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;] let week = weeks[formatter.dateFromString(dateString)!.resultWeek()] 结果是星期六 ####4.判断两个日期时间差 let firstDate = &quot;2016-09-24&quot; let secondDate = &quot;2016-12-24&quot; let cformatter = NSDateFormatter() cformatter.dateFormat = &quot;yyyy-MM-dd&quot; let sDate = cformatter.dateFromString(firstDate) let cDate = cformatter.dateFromString(secondDate) let intervals = cDate?.timeIntervalSinceDate(sDate!) //时间差(单位是秒) let day_seconds = 24*3600 //一天的秒数 let days = Int(intervals!)/day_seconds //结果就是两个日期的时间差(单位是天)]]></content>
  </entry>
  <entry>
    <title><![CDATA[TCP与UDP区别]]></title>
    <url>%2F2019%2F01%2F10%2FTCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 UDP补充：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。 TCP补充：TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列七——三维中的球型布局]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E4%B8%89%E7%BB%B4%E4%B8%AD%E7%9A%84%E7%90%83%E5%9E%8B%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、引言通过6篇的博客，从平面上最简单的规则摆放的布局，到不规则的瀑布流布局，再到平面中的圆环布局，我们突破了线性布局的局限，在后面，我们将布局扩展到了空间，在Z轴上进行了平移，我们实现了一个类似UIPickerView的布局模型，其实我们还可以再进一步，类比于平面布局，picKerView只是线性排列布局在空间上的旋转与平移，这次，我们更加充分了利用一下空间的尺寸，来设计一个圆球的布局模型。 二、将布局扩展为空间球型在viewController中先实现一些准备代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.MyLayout * layout = [[MyLayout alloc]init];UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];collect.delegate=self;collect.dataSource=self;//这里设置的偏移量是为了无缝进行循环的滚动，具体在上一篇博客中有解释collect.contentOffset = CGPointMake(320, 400);[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];[self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;//我们返回30的标签-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 30;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)];label.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row];[cell.contentView addSubview:label];return cell;&#125;- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];// Dispose of any resources that can be recreated.&#125;//这里对滑动的contentOffset进行监控，实现循环滚动-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;if (scrollView.contentOffset.y&lt;200) &#123;scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y+10*400);&#125;else if(scrollView.contentOffset.y&gt;11*400)&#123;scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y-10*400);&#125;if (scrollView.contentOffset.x&lt;160) &#123;scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x+10*320,scrollView.contentOffset.y);&#125;else if(scrollView.contentOffset.x&gt;11*320)&#123;scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x-10*320,scrollView.contentOffset.y);&#125;&#125; 这里面的代码比较上一篇博客中的并没有什么大的改动，只是做了横坐标的兼容。 在我们的layout类中，将代码修改成如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void)prepareLayout&#123;[super prepareLayout];&#125;//返回的滚动范围增加了对x轴的兼容-(CGSize)collectionViewContentSize&#123;return CGSizeMake( self.collectionView.frame.size.width*([self.collectionView numberOfItemsInSection:0]+2), self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125;-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123;return YES;&#125;-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];//获取item的个数int itemCounts = (int)[self.collectionView numberOfItemsInSection:0];atti.center = CGPointMake(self.collectionView.frame.size.width/2+self.collectionView.contentOffset.x, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y);atti.size = CGSizeMake(30, 30);CATransform3D trans3D = CATransform3DIdentity;trans3D.m34 = -1/900.0;CGFloat radius = 15/tanf(M_PI*2/itemCounts/2);//根据偏移量 改变角度//添加了一个x的偏移量float offsety = self.collectionView.contentOffset.y;float offsetx = self.collectionView.contentOffset.x;//分别计算偏移的角度float angleOffsety = offsety/self.collectionView.frame.size.height;float angleOffsetx = offsetx/self.collectionView.frame.size.width;CGFloat angle1 = (float)(indexPath.row+angleOffsety-1)/itemCounts*M_PI*2;//x，y的默认方向相反CGFloat angle2 = (float)(indexPath.row-angleOffsetx-1)/itemCounts*M_PI*2;//这里我们进行四个方向的排列if (indexPath.row%4==1) &#123;trans3D = CATransform3DRotate(trans3D, angle1, 1.0,0, 0);&#125;else if(indexPath.row%4==2)&#123;trans3D = CATransform3DRotate(trans3D, angle2, 0, 1, 0);&#125;else if(indexPath.row%4==3)&#123;trans3D = CATransform3DRotate(trans3D, angle1, 0.5,0.5, 0);&#125;else&#123;trans3D = CATransform3DRotate(trans3D, angle1, 0.5,-0.5,0);&#125;trans3D = CATransform3DTranslate(trans3D, 0, 0, radius);atti.transform3D = trans3D;return atti;&#125;-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;NSMutableArray * attributes = [[NSMutableArray alloc]init];//遍历设置每个item的布局属性for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123;[attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]];&#125;return attributes;&#125; 布局效果如下： 滑动屏幕，这个圆球是可以进行滚动的。 TIP：这里我们只平均分配了四个方向上的布局，如果item更加小也更加多，我们可以分配到更多的方向上，使球体更加充实。 转自https://my.oschina.net/u/2340880/blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列三、使用FlowLayout进行更灵活布局]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8FlowLayout%E8%BF%9B%E8%A1%8C%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、引言前面的博客介绍了UICollectionView的相关方法和其协议中的方法，但对布局的管理类UICollectionViewFlowLayout没有着重探讨，这篇博客介绍关于布局的相关设置和属性方法。通过layout的设置，我们可以编写更加灵活的布局效果。 二、将九宫格式的布局进行升级在第一篇博客中，通过UICollectionView，我们很轻松的完成了一个九宫格的布局，但是如此中规中矩的布局方式，有时候并不能满足我们的需求，有时我们需要每一个Item展示不同的大小，代码如下：123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init];layout.scrollDirection = UICollectionViewScrollDirectionVertical;UICollectionView *collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];collect.delegate=self;collect.dataSource=self;[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];;[self.view addSubview:collect];&#125;//设置每个item的大小，双数的为50*50 单数的为100*100-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123;if (indexPath.row%2==0) &#123;return CGSizeMake(50, 50);&#125;else&#123;return CGSizeMake(100, 100);&#125;&#125;//代理相应方法-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];return cell;&#125; 效果如下： 现在的布局效果是不是炫酷了许多。 三、UICollectionViewFlowLayout相关属性方法UICollectionViewFlowLayout是系统提供给我们一个封装好的流布局设置类，其中有一些布局属性我们可以进行设置： 设置行与行之间的间距最小距离 @property (nonatomic) CGFloat minimumLineSpacing; 设置列与列之间的间距最小距离 @property (nonatomic) CGFloat minimumInteritemSpacing; 设置每个item的大小 @property (nonatomic) CGSize itemSize; 设置每个Item的估计大小，一般不需要设置 @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); 设置布局方向 @property (nonatomic) UICollectionViewScrollDirection scrollDirection; 这个UICollectionViewScrollDirection的枚举如下： 设置头视图尺寸大小 @property (nonatomic) CGSize headerReferenceSize; 设置尾视图尺寸大小 @property (nonatomic) CGSize footerReferenceSize; 设置分区的EdgeInset @property (nonatomic) UIEdgeInsets sectionInset; 这个属性可以设置分区的偏移量，例如我们在刚才的例子中添加如下设置： 效果如下，会看到分区的边界闪出了20像素 下面这两个方法设置分区的头视图和尾视图是否始终固定在屏幕上边和下边 @property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); @property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); 四、动态的配置layout的相关属UICollectionViewDelegateFlowLayout 上面的方法在创建FlowLayout时静态的进行设置，如果我们需要动态的设置这些属性，就像我们例子中的，每个item的大小会有差异，我们可以通过代理来实现。 UICollectionViewDelegateFlowLayout是UICollectionViewDelegate的子协议，其中常用方法如下，我们只需要实现我们需要的即可： 动态设置每个Item的尺寸大小 (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath; 动态设置每个分区的EdgeInsets (UIEdgeInsets)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; 动态设置每行的间距大小 (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section; 动态设置每列的间距大小 (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section; 动态设置某个分区头视图大小 (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section; 动态设置某个分区尾视图大小 (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列二、UICollectionView的代理方法]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E4%BA%8C%E3%80%81UICollectionView%E7%9A%84%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、引言 在上一篇博客中，介绍了最基本的UICollectionView的使用和其中我们常用的属性和方法，也介绍了瀑布流布局的过程与思路，这篇博客来讨论关于UICollectionView的代理方法的使用。 ###二、UICollectionViewDataSource协议 这个协议主要用于collectionView相关数据的处理，包含方法如下： 首先，有两个方法是我们必须实现的： 设置每个分区的Item个数 1 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; 设置返回每个item的属性 1 - (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 下面的方法是可选实现的： 虽然这个方法是可选的，一般我们都会去实现，设置分区数 1 - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView; 对头视图或者尾视图进行设置 1 - (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath; 设置某个item是否可以被移动，返回NO则不能移动 1 - (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0); 移动item的时候，会调用这个方法 1 - (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath； 三、UICollectionViewDelegate协议这个协议用来设置和处理collectionView的功能和一些逻辑，所有方法都是可选实现： 是否允许某个Item的高亮，返回NO，则不能进入高亮状态 1 - (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath; 当item高亮时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath; 结束高亮状态时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath; 是否可以选中某个Item，返回NO，则不能选中 1 - (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath; 是否可以取消选中某个Item 1 - (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath; 已经选中某个item时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath; 取消选中某个Item时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath; 将要加载某个Item时调用的方法 1 - (void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0); 将要加载头尾视图时调用的方法 1 - (void)collectionView:(UICollectionView *)collectionView willDisplaySupplementaryView:(UICollectionReusableView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0); 已经展示某个Item时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didEndDisplayingCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath; 已经展示某个头尾视图时触发的方法 1 - (void)collectionView:(UICollectionView *)collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath; 这个方法设置是否展示长按菜单 1 - (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath; 长按菜单中可以触发一下类复制粘贴的方法，效果如下： ![20170628101530112.png](https://upload-images.jianshu.io/upload_images/4055583-5cb8b156f1dbff1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 这个方法用于设置要展示的菜单选项 1 - (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender; 这个方法用于实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用 1 - (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender; 通过下面的方式可以将点击按钮的方法名打印出来： collectionView进行重新布局时调用的方法 1 - (nonnull UICollectionViewTransitionLayout *)collectionView:(UICollectionView *)collectionView transitionLayoutForOldLayout:(UICollectionViewLayout *)fromLayout newLayout:(UICollectionViewLayout *)toLayout;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列五——UICollectionView圆环布局的实现]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94UICollectionView%E5%9C%86%E7%8E%AF%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、引言前边的几篇博客，我们了解了UICollectionView的基本用法以及一些扩展，在不定高的瀑布流布局中，我们发现，可以通过设置具体的布局属性类UICollectionViewLayoutAttributes来设置设置每个item的具体位置，我们可以再扩展一下，如果位置我们可以自由控制，那个布局我们也可以更加灵活，就比如创建一个如下的circleLayout： 这种布局方式在apple的官方文档中也有介绍，是UICollectionView的一个应用示例。 二、设计一个圆环布局先自定义一个layout类，这个类继承于UICollectionViewLayout，UICollectionLayout是一个布局抽象基类，我们要使用自定义的布局方式，必须将其子类化，可能你还记得，我们在进行瀑布流布局的时候使用过UICollectionViewFlowLayout类，这个类就是继承于UICollectionViewLayout类，系统为我们实现好的一个布局方案。1234@interface MyLayout : UICollectionViewLayout//这个int值存储有多少个item@property(nonatomic,assign)int itemCount;@end 我们需要重写这个类的三个方法，来进行圆环布局的设置，首先是prepareLayout，为布局做一些准备工作，使用collectionViewContentSize来设置内容的区域大小，最后使用layoutAttributesForElementsInRect方法来返回我们的布局信息字典，这个和前面瀑布流布局的思路是一样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@implementation MyLayout&#123;NSMutableArray * _attributeAttay;&#125;-(void)prepareLayout&#123;[super prepareLayout];//获取item的个数_itemCount = (int)[self.collectionView numberOfItemsInSection:0];_attributeAttay = [[NSMutableArray alloc]init];//先设定大圆的半径 取长和宽最短的CGFloat radius = MIN(self.collectionView.frame.size.width, self.collectionView.frame.size.height)/2;//计算圆心位置CGPoint center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2);//设置每个item的大小为50*50 则半径为25for (int i=0; i&lt;_itemCount; i++) &#123;UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:[NSIndexPath indexPathForItem:i inSection:0]];//设置item大小attris.size = CGSizeMake(50, 50);//计算每个item的圆心位置/*.. .. . r. ..........*///计算每个item中心的坐标//算出的x y值还要减去item自身的半径大小float x = center.x+cosf(2*M_PI/_itemCount*i)*(radius-25);float y = center.y+sinf(2*M_PI/_itemCount*i)*(radius-25);attris.center = CGPointMake(x, y);[_attributeAttay addObject:attris];&#125;&#125;//设置内容区域的大小-(CGSize)collectionViewContentSize&#123;return self.collectionView.frame.size;&#125;//返回设置数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;return _attributeAttay;&#125; 在viewController中代码如下：12345678910111213141516171819202122232425- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.MyLayout * layout = [[MyLayout alloc]init];UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];collect.delegate=self;collect.dataSource=self;[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];[self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.layer.masksToBounds = YES;cell.layer.cornerRadius = 25;cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];return cell;&#125; 如上非常简单的一些逻辑控制，我们就实现哦圆环布局，随着item的多少，布局会自动调整，如果不是UICollectionView的功劳，实现这样的功能，我们可能要写上一阵子了^_^。]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列四、自定义FlowLayout进行瀑布流布局]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89FlowLayout%E8%BF%9B%E8%A1%8C%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、引言前几篇博客从UICollectionView的基础应用到设置UICollectionViewFlowLayout更加灵活的进行布局，但都限制在系统为我们准备好的布局框架中，还是有一些局限性，例如，如果我要进行瀑布流似的不定高布局，前面的方法就很难满足我们的需求了，如下： 这种布局无疑在app的应用中更加广泛，商品的展示，书架书目的展示，都会倾向于采用这样的布局方式，当然，通过自定义FlowLayout，我们也很容易实现。 二、进行自定义瀑布流布局首先，我们新建一个文件继承于UICollectionViewFlowLayout：1@interface MyLayout : UICollectionViewFlowLayout 为了演示的方便，这里我不做更多的封装，只添加一个属性，直接让外界将item个数传递进来，我们把重心方法重写布局的方法上：123@interface MyLayout : UICollectionViewFlowLayout@property(nonatomic,assign)int itemCount;@end 前面说过，UICollectionViewFlowLayout是一个专门用来管理collectionView布局的类，因此，collectionView在进行UI布局前，会通过这个FlowLayout的对象获取相关的布局信息，FlowLayout类将这些布局信息全部存放在了一个数组中，数组中是UICollectionViewLayoutAttributes类，这个类是对item布局的具体设置，以后咱们在讨论这个类。总之，FlowLayout类将每个item的位置等布局信息放在一个数组中，在collectionView布局时，会调用FlowLayout类layoutAttributesForElementsInRect：方法来获取这个布局配置数组。因此，我们需要重写这个方法，返回我们自定义的配置数组另外，FlowLayout类在进行布局之前，会调用prepareLayout方法，所以我们可以重写这个方法，在里面对我们的自定义配置数据进行一些设置。 简单来说，自定义一个FlowLayout布局类就是两个步骤： 1、设计好我们的布局配置数据 prepareLayout方法中 2、返回我们的配置数组 layoutAttributesForElementsInRect方法中 示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation MyLayout&#123;//这个数组就是我们自定义的布局配置数组NSMutableArray * _attributeAttay;&#125;//数组的相关设置在这个方法中//布局前的准备会调用这个方法-(void)prepareLayout&#123;_attributeAttay = [[NSMutableArray alloc]init];[super prepareLayout];//演示方便 我们设置为静态的2列//计算每一个item的宽度float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2;//定义数组保存每一列的高度//这个数组的主要作用是保存每一列的总高度，这样在布局时，我们可以始终将下一个Item放在最短的列下面CGFloat colHight[2]=&#123;self.sectionInset.top,self.sectionInset.bottom&#125;;//itemCount是外界传进来的item的个数 遍历来设置每一个item的布局for (int i=0; i&lt;_itemCount; i++) &#123;//设置每个item的位置等相关属性NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0];//创建一个布局属性类，通过indexPath来创建UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index];//随机一个高度 在40——190之间CGFloat hight = arc4random()%150+40;//哪一列高度小 则放到那一列下面//标记最短的列int width=0;if (colHight[0]&lt;colHight[1]) &#123;//将新的item高度加入到短的一列colHight[0] = colHight[0]+hight+self.minimumLineSpacing;width=0;&#125;else&#123;colHight[1] = colHight[1]+hight+self.minimumLineSpacing;width=1;&#125;//设置item的位置attris.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*width, colHight[width]-hight-self.minimumLineSpacing, WIDTH, hight);[_attributeAttay addObject:attris];&#125;//设置itemSize来确保滑动范围的正确 这里是通过将所有的item高度平均化，计算出来的(以最高的列位标准)if (colHight[0]&gt;colHight[1]) &#123;self.itemSize = CGSizeMake(WIDTH, (colHight[0]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing);&#125;else&#123;self.itemSize = CGSizeMake(WIDTH, (colHight[1]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing);&#125;&#125;//这个方法中返回我们的布局数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;return _attributeAttay;&#125;@end 自定义完成FlowLayout后，我们在ViewController中进行使用：123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.MyLayout * layout = [[MyLayout alloc]init];layout.scrollDirection = UICollectionViewScrollDirectionVertical;layout.itemCount=100;UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];collect.delegate=self;collect.dataSource=self;[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];[self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];return cell;&#125; 运行效果就是我们引言中的截图。 三、UICollectionViewLayoutAttributes类中我们可以配置的属性通过上面的例子，我们可以了解，collectionView的item布局其实是LayoutAttributes类具体配置的，这个类可以配置的布局属性不止是frame这么简单，其中还有许多属性：12345678910111213141516171819202122232425262728//配置item的布局位置@property (nonatomic) CGRect frame;//配置item的中心@property (nonatomic) CGPoint center;//配置item的尺寸@property (nonatomic) CGSize size;//配置item的3D效果@property (nonatomic) CATransform3D transform3D;//配置item的bounds@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);//配置item的旋转@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);//配置item的alpha@property (nonatomic) CGFloat alpha;//配置item的z坐标@property (nonatomic) NSInteger zIndex; // default is 0//配置item的隐藏@property (nonatomic, getter=isHidden) BOOL hidden; //item的indexpath@property (nonatomic, strong) NSIndexPath *indexPath;//获取item的类型@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; //一些创建方法+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath; 通过上面的属性，可以布局出各式各样的炫酷效果，正如一句话：没有做不到，只有想不到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[今天是个人博客开通的第一天，搞了半天终于好了，好激动！！！以前自己做的学习记录有在本地文件的，有在备忘录的，有在简书的。。。反正就是各种地方，很多慢慢都找不到了。这次正好最近闲下来整理下。慢慢的都放到自己的博客中。 我有一头小毛驴，可是我从来都不骑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 宏(define)与常量(const)以及extern]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%20%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)%E4%BB%A5%E5%8F%8Aextern%2F</url>
    <content type="text"><![CDATA[###思考下，下面的有什么不同，分别在什么时候使用呢？12345678910#define HSCoder @&quot;汉斯哈哈哈&quot;NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;extern NSString *HSCoder;extern const NSString *HSCoder;static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;; ###当我们想全局共用一些数据时，可以用宏、变量、常量 宏：1#define HSCoder @&quot;汉斯哈哈哈&quot; 变量：1NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; 常量：12345四种写法：static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;; 宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大 变量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段会执行类型检查 常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查 ###const和static const区分1234const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;; //本文件内部的全局常量static const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;//用static修饰后，不能提供外界访问,只能在本文件内访问,或者导入本文件可用（iOS中只有.h文件的导入，所以定义在.h中，如果导入.h头文件那么外部也可以用，如果定义在.m则只能在.m本文件内部使用） ###const修饰位置const右边的总不能被修改123456781.const NSString *HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改2.NSString const *HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改3.NSString * const HSCoder = @&quot;汉斯哈哈哈&quot;;&quot;HSCoder&quot;不能被修改，&quot;*HSCoder&quot;能被修改 “static作用”: 修饰局部变量： 1.延长局部变量的生命周期,程序结束才会销毁。 2.局部变量只会生成一份内存,只会初始化一次。 3.改变局部变量的作用域。 修饰全局变量 1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改 2.避免重复定义全局变量 ####const作用：限制类型 1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p） 2.被const修饰的变量是只读的。 ####”extern作用”: 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 “extern工作原理”: 先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 知识补充：对于指针a来说，*a就是指针a所指向的内存空间存储的值,&amp;a就是存储这个变量的内存地址,a是指针名 staic和const联合的作用:声明一个静态的全局只读常量,在”一个文件中”经常使用的字符串常量，可以使用static与const组合 extern与const组合的作用：在”多个文件中”经常使用的同一个字符串常量，可以使用extern与const组合。 static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合:只需要定义一份全局变量，多个文件共享]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 协议中定义属性]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1234@protocol CETableViewModelProtocol &lt;NSObject&gt;@property (nonatomic, strong) Class cellClass;@property (nonatomic, copy ) NSString* cellType;@end 协议中是可以定义属性的，但是只有对应的getter和setter方法 但是没有对应的成员变量 而getter和setter就是操作的对应成员变量 所以就无法调用getter或者setter 否则项目崩溃 想要调用的话 需要在实现这个协议的类中用@synthesize cellType = _cellType;来声明成员变量,这样这个类的对象就拥有了协议中定义的这些属性，用法跟自身其他属性一样就不啰嗦了。 来看看实例吧： .h123456789#import &lt;Foundation/Foundation.h&gt;#import &quot;CETableViewModelProtocol.h&quot;NS_ASSUME_NONNULL_BEGIN@interface CETableViewModel : NSObject &lt;CETableViewModelProtocol&gt;@endNS_ASSUME_NONNULL_END .m 123456#import &quot;CETableViewModel.h&quot;@implementation CETableViewModel@synthesize cellHeight = _cellHeight;@synthesize cellType = _cellType;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS中的@synthesize]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%B8%AD%E7%9A%84%40synthesize%2F</url>
    <content type="text"><![CDATA[常见的有两种用法 其实是一个意思 @synthesize student; 等价于 @synthesize student = student @synthesize student = _student ARC下 通过@property声明的属性，编译器会自动声明对应的成员变量和getter/setter方法 而@synthesize student = _student就是程序猿自己显式地声明属性对应的成员变量，而不用编译器自生成的 我们知道getter和setter方法里面操作的其实就是属性对应的成员变量 成员变量其实本质上就是一个变量指针 那么调用两者有什么区别呢？12self.name = @&quot;我信你个鬼&quot;;_name = @&quot;我信你个大头鬼&quot;; self.name本质上是调用的setter方法setName() 而setter方法是依赖于@property的属性修饰符的，比如retain，assign等属性。也就是会影响其引用计数 而_name = @”我信你个大头鬼” 只是变量的赋值 不涉及retain、assign等]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS之创建一个常驻线程]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%B9%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[常驻线程有什么用呢？让一个一直存在的子线程，等待其他线程发来消息，处理其他事件。 注意 ：不要使用GCD的global队列创建常驻线程原因：global全局队列，整个工程共用的队列，队列里的所有线程都会放进一个线程池中，当线程池满了的时候，就会进入等待状态，后面加进来的block就不会创建新的线程执行了 等待前面的任务执行完成，才会继续执行。如果线程池中的线程长时间不结束，后续堆积的任务会越来越多12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@interface LongThreadDemoController ()@property (nonatomic, strong) NSThread *thread;@end@implementation LongThreadDemoController- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor whiteColor];self.title = @&quot;常驻线程Demo&quot;;&#125;- (void)threadRunloopPoint:(id)__unused object&#123;NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));@autoreleasepool &#123;[[NSThread currentThread] setName:@&quot;changzhuThread&quot;];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];//// 这里主要是监听某个 port，目的是让这个 Thread 不会回收[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];&#125;&#125;- (NSThread *)thread&#123;if(!_thread)&#123;_thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadRunloopPoint:) object:nil];[_thread start];&#125;return _thread;&#125;- (void)test&#123;NSLog(@&quot;%s&quot;,__func__);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;[self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS保存图片到相册]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425导入系统框架#import &lt;Photos/Photos.h&gt;- (void)clickQRCode:(UIImage *)image&#123;[MBProgressHUD HUDForView:self.view];[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;[PHAssetChangeRequest creationRequestForAssetFromImage:image];&#125; completionHandler:^(BOOL success, NSError * _Nullable error) &#123;NSLog(@&quot;success = %d, error = %@&quot;, success, error);dispatch_async(dispatch_get_main_queue(), ^&#123;[MBProgressHUD hideHUDForView:self.view];if (success) &#123;[MBProgressHUD showSuccess:@&quot;保存成功&quot; toView:self.view];&#125;else&#123;UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;请在“设置-隐私”中允许空能净访问您的照片&quot; message:nil delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil];[alert show];&#125;&#125;);&#125;];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS图片拉伸]]></title>
    <url>%2F2019%2F01%2F10%2FiOS%E5%9B%BE%E7%89%87%E6%8B%89%E4%BC%B8%2F</url>
    <content type="text"><![CDATA[123456789101112UIImage * img = [UIImage imageNamed:@&quot;3X&quot;];float w = img.size.width;float h = img.size.height;//图片拉伸 当imgview的frame跟img不一样大时就会拉伸图片来填充//第一个参数 UIEdgeInsets 是规定上下左右到img边的部分不拉伸受到保护 中间部分进行拉伸//UIImageResizingModeStretch 拉伸//UIImageResizingModeTile 平铺UIImage * newImg = [img resizableImageWithCapInsets:UIEdgeInsetsMake(h * 0.5, w * 0.5, h * 0.5, w * 0.5) resizingMode:UIImageResizingModeStretch];]]></content>
  </entry>
  <entry>
    <title><![CDATA[tableviewcell注册和不注册的区别及用法]]></title>
    <url>%2F2019%2F01%2F10%2Ftableviewcell%E6%B3%A8%E5%86%8C%E5%92%8C%E4%B8%8D%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注册和不注册的区别主要看下面这两个方法： 1234567- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.(返回给代理一个已经分配的cell，代替一个新的cell，如果没有已分配的cell，则返回nil，使用这个方法就不需要注册了)- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 如果cell的identifier是注册过的，那么这个新列出的方法保证返回一个cell (有分配的就返回已分配的cell，没有返回新的cell)并适当调整大小，可省略cell空值判断步骤，用这个方法cell必须注册,不是自定义的cell，UITableViewCell也要注册]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码修改xib约束的值注意]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9xib%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%80%BC%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[有时候在初始化中或者viewdidload中直接改变top.constant的值没有用，可能是因为代码设置后 xib后更新（xib加载在代码设置后） 这个时候使用延迟加载即可 123456[self performSelector:@selector(modifyConstant) withObject:nil afterDelay:0.1];//延迟加载,执行- (void)modifyConstant&#123;self.topSafeH.constant += 100;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决Mac和iOS模拟器间拷贝粘贴的问题]]></title>
    <url>%2F2019%2F01%2F10%2F%E8%A7%A3%E5%86%B3Mac%E5%92%8CiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%97%B4%E6%8B%B7%E8%B4%9D%E7%B2%98%E8%B4%B4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、检查模拟器的Edit &gt; Automatically Sync Pasteboard是否勾选 如果失效了可以关闭再打开试试2、按照上述操作还不行的,注意 HardWare =&gt; keyboard =&gt; send menu keyboard … 处于勾选状态~]]></content>
  </entry>
  <entry>
    <title><![CDATA[NSOperation、NSOperationQueue]]></title>
    <url>%2F2019%2F01%2F10%2FNSOperation%E3%80%81NSOperationQueue%2F</url>
    <content type="text"><![CDATA[####一、 为什么要使用 NSOperation、NSOperationQueueNSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。可添加完成的代码块，在操作完成后执行。添加操作之间的依赖关系，方便的控制执行顺序。设定操作执行的优先级。可以很方便的取消一个操作的执行。使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 ####二、同步异步以及并行串行的区别同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态并行串行是指有多个线程的任务的执行方式，串行则多个任务按顺序执行，并行则多个任务会同时执行 三、 NSOperation 实现多线程的使用步骤分为三步：NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 1、创建操作：先将需要执行的操作封装到一个NSOperation 对象中。2、创建队列：创建NSOperationQueue对象。3、将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 ####四、线程死锁12345// NSLog(@&quot;1&quot;);// dispatch_sync(dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;2&quot;);// &#125;);// NSLog(@&quot;3&quot;); 主线程是串行队列, 一个任务执行完成才能往下执行, 同步线程是一个任务A ,里面的block是同步线程插入到当前线程的另一个任务B ,A要等B执行完才返回 ,B要等A执行完才能执行 ,会相互等待 造成死锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.// 创建操作// [self useInvocationOperation];//// NSOperation单独使用 同步执行 等待结果返回后执行后面语句// NSLog(@&quot;下一个语句&quot;);// [self useBlockOperation];// 创建队列// [self addOperationToQueue];// 添加依赖// [self addDependency];// 优先级// [self queuePriority];// 线程间通讯// [self communication];// 线程死锁：主线程是串行队列 一个任务执行完成才能往下执行 同步线程是一个任务A 里面的block是同步线程插入到当前线程的另一个任务B A要等B执行完才返回 B要等A执行完才能执行 会相互等待 造成死锁// NSLog(@&quot;1&quot;);// dispatch_sync(dispatch_get_main_queue(), ^&#123;// NSLog(@&quot;2&quot;);// &#125;);// NSLog(@&quot;3&quot;);&#125;#pragma mark - 创建操作//NSOperation 单独使用时系统同步执行操作//NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。//使用子类 NSInvocationOperation//使用子类 NSBlockOperation//自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。- (void)useInvocationOperation&#123;NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 开始操作[invocationOperation start];&#125;//NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行(完成顺序是不一定的)。只有当所有相关的操作已经完成执行时，才视为完成//一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。- (void)useBlockOperation&#123;NSBlockOperation * blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;blockOperation---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 2.添加额外的操作[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[blockOperation addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 调用 start 方法开始执行操作[blockOperation start];&#125;- (void)useCustomOperation&#123;&#125;#pragma mark - 创建队列//NSOperationQueue 创建的自定义队列同时具有串行、并发功能，通过设置属性maxConcurrentOperationCount（最大并发操作数）用来控制一个特定队列中可以有多少个操作同时参与并发执行。//当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理//那么我们需要将创建好的操作加入到队列中去。总共有两种方法：//1、- (void)addOperation:(NSOperation *)op;//2、- (void)addOperationWithBlock:(void (^)(void))block;/*** 使用 addOperation: 将操作加入到操作队列中*/- (void)addOperationToQueue &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 设置最大并发操作数 来控制队列的串行或者并发queue.maxConcurrentOperationCount = 1;// queue.maxConcurrentOperationCount = 8;// 2.创建操作// 使用 NSInvocationOperation 创建操作1NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];op1.queuePriority = NSOperationQueuePriorityHigh;op2.queuePriority = NSOperationQueuePriorityLow;// 使用 NSBlockOperation 创建操作3NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[op3 addExecutionBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 3.使用 addOperation: 添加所有操作到队列中[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start[queue addOperation:op2]; // [op2 start][queue addOperation:op3]; // [op3 start]&#125;/*** 使用 addOperationWithBlock: 将操作加入到操作队列中无需自己创建操作对象 直接将操作放到block中*/- (void)addOperationWithBlockToQueue &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.使用 addOperationWithBlock: 添加操作到队列中[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];[queue addOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];&#125;#pragma mark - NSOperation 操作依赖//NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。//- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。//- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。//@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。- (void)addDependency &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.创建操作NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];// 3.添加依赖[op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2// 4.添加操作到队列中[queue addOperation:op1];[queue addOperation:op2];&#125;#pragma mark - NSOperation 优先级 &amp; 服务质量（只是尽可能的 并不是绝对的）//NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。//对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）//准备就绪状态：当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行//queuePriority 属性（尽可能的并不是绝对的）决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。//如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。//如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系- (void)queuePriority&#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 设置最大并发操作数 来控制队列的串行或者并发// queue.maxConcurrentOperationCount = 1; //串行// queue.maxConcurrentOperationCount = 8;//并发// 2.创建操作// 使用 NSInvocationOperation 创建操作1NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask2) object:nil];// 使用 NSInvocationOperation 创建操作2NSInvocationOperation *op3 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationTask3) object:nil];// 同一个队列中的操作优先级 执行的先后 并不是结束的先后// op1.queuePriority = NSOperationQueuePriorityVeryHigh;// op2.queuePriority = NSOperationQueuePriorityHigh;// op3.queuePriority = NSOperationQueuePriorityNormal;// 服务质量 在iOS 8.0前,通过设置操作的优先级,尽可能的保证某个操作优先处理,随着硬件性能上的提升,通过设置优先级效果已经越来越不明显,在iOS 8.0后,推出了服务质量,通过设置服务质量,让系统优先处理某一个操作 目前也是越来越不明显// op1.qualityOfService = NSQualityOfServiceUserInteractive;// op2.qualityOfService = NSQualityOfServiceBackground;// op3.qualityOfService = NSQualityOfServiceDefault;// 3.使用 addOperation: 添加所有操作到队列中[queue addOperation:op1]; // [op1 start] 添加到队列中 无需再自己调用start[queue addOperation:op2]; // [op2 start][queue addOperation:op3]; // [op3 start]&#125;#pragma mark - NSOperation、NSOperationQueue 线程间的通信/*** 线程间通信*/- (void)communication &#123;// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];// 2.添加操作[queue addOperationWithBlock:^&#123;// 异步进行耗时操作for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;// 回到主线程[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;// 进行一些 UI 刷新等操作for (int i = 0; i &lt; 2; i++) &#123;[NSThread sleepForTimeInterval:2]; // 模拟耗时操作NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;&#125;];&#125;];&#125;#pragma mark - 执行的操作- (void)invocationTask&#123;NSLog(@&quot;1&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation1---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;- (void)invocationTask2&#123;NSLog(@&quot;2&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation2---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;- (void)invocationTask3&#123;NSLog(@&quot;3&quot;);for (int i = 0; i &lt; 2; i++) &#123;NSLog(@&quot;invocationOperation3---%@&quot;, [NSThread currentThread]); // 打印当前线程[NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;&#125;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列一、初识与简单使用UICollectionView]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8UICollectionView%2F</url>
    <content type="text"><![CDATA[###一、简介UICollectionView是iOS6之后引入的一个新的UI控件，它和UITableView有着诸多的相似之处，其中许多代理方法都十分类似。简单来说，UICollectionView是比UITbleView更加强大的一个UI控件，有如下几个方面： 1、支持水平和垂直两种方向的布局 2、通过layout配置方式进行布局 3、类似于TableView中的cell特性外，CollectionView中的Item大小和位置可以自由定义 4、通过layout布局回调的代理方法，可以动态的定制每个item的大小和collection的大体布局属性 5、更加强大一点，完全自定义一套layout布局方案，可以实现意想不到的效果 二、先来实现一个最简单的九宫格类布局在了解UICollectionView的更多属性前，我们先来使用其进行一个最简单的流布局试试看，在controller的viewDidLoad中添加如下代码：123456789101112131415//创建一个layout布局类UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init];//设置布局方向为垂直流布局layout.scrollDirection = UICollectionViewScrollDirectionVertical;//设置每个item的大小为100*100layout.itemSize = CGSizeMake(100, 100);//创建collectionView 通过一个布局策略layout来创建UICollectionView * collect = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout];//代理设置collect.delegate=self;collect.dataSource=self;//注册item类型 这里使用系统的类型[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];[self.view addSubview:collect]; 这里有一点需要注意，collectionView在完成代理回调前，必须注册一个cell，类似如下:1[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; 这和tableView有些类似，又有些不同，因为tableView除了注册cell的方法外，还可以通过临时创建来做：12345//tableView在从复用池中取cell的时候，有如下两种方法//使用这种方式如果复用池中无，是可以返回nil的，我们在临时创建即可- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;//6.0后使用如下的方法直接从注册的cell类获取创建，如果没有注册 会崩溃- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); 我们可以分析：因为UICollectionView是iOS6.0之前的新类，因此这里统一了从复用池中获取cell的方法，没有再提供可以返回nil的方式，并且在UICollectionView的回调代理中，只能使用从复用池中获取cell的方式进行cell的返回，其他方式会崩溃，例如：1234567891011121314//这是正确的方法-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];return cell;&#125;//这样做会崩溃-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;// UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];// cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];UICollectionViewCell * cell = [[UICollectionViewCell alloc]init];return cell;&#125; 上面错误的方式会崩溃，信息如下，让我们使用从复用池中取cell的方式： [图片上传失败…(image-9b7f2f-1527661822069)] 上面的设置完成后，我们来实现如下几个代理方法：这里与TableView的回调方式十分类似 1234567891011121314//返回分区个数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;//返回每个分区的item个数-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 10;&#125;//返回每个item-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];return cell;&#125; 效果如下： 同样，如果内容的大小超出一屏，和tableView类似是可以进行视图滑动的。 还有一点细节，我们在上面设置布局方式的时候设置了垂直布局：123layout.scrollDirection = UICollectionViewScrollDirectionVertical;//这个是水平布局//layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 这样系统会在一行充满后进行第二行的排列，如果设置为水平布局，则会在一列充满后，进行第二列的布局，这种方式也被称为流式布局 ###三、UICollectionView中的常用方法和属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//通过一个布局策略初识化CollectionView- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;//获取和设置collection的layout@property (nonatomic, strong) UICollectionViewLayout *collectionViewLayout;//数据源和代理@property (nonatomic, weak, nullable) id &lt;UICollectionViewDelegate&gt; delegate;@property (nonatomic, weak, nullable) id &lt;UICollectionViewDataSource&gt; dataSource;//从一个class或者xib文件进行cell(item)的注册- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;//下面两个方法与上面相似，这里注册的是头视图或者尾视图的类//其中第二个参数是设置 头视图或者尾视图 系统为我们定义好了这两个字符串//UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);//UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;//这两个方法是从复用池中取出cell或者头尾视图- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;//设置是否允许选中 默认yes@property (nonatomic) BOOL allowsSelection;//设置是否允许多选 默认no@property (nonatomic) BOOL allowsMultipleSelection;//获取所有选中的item的位置信息- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForSelectedItems; //设置选中某一item，并使视图滑动到相应位置，scrollPosition是滑动位置的相关参数，如下：/*typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123;//无UICollectionViewScrollPositionNone = 0,//垂直布局时使用的 对应上中下UICollectionViewScrollPositionTop = 1 &lt;&lt; 0,UICollectionViewScrollPositionCenteredVertically = 1 &lt;&lt; 1,UICollectionViewScrollPositionBottom = 1 &lt;&lt; 2,//水平布局时使用的 对应左中右UICollectionViewScrollPositionLeft = 1 &lt;&lt; 3,UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4,UICollectionViewScrollPositionRight = 1 &lt;&lt; 5&#125;;*/- (void)selectItemAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UICollectionViewScrollPosition)scrollPosition;//将某一item取消选中- (void)deselectItemAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;//重新加载数据- (void)reloadData;//下面这两个方法，可以重新设置collection的布局，后面的方法多了一个布局完成后的回调，iOS7后可以用//使用这两个方法可以产生非常炫酷的动画效果- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated;- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);//下面这些方法更加强大，我们可以对布局更改后的动画进行设置//这个方法传入一个布局策略layout，系统会开始进行布局渲染，返回一个UICollectionViewTransitionLayout对象//这个UICollectionViewTransitionLayout对象管理动画的相关属性，我们可以进行设置- (UICollectionViewTransitionLayout *)startInteractiveTransitionToCollectionViewLayout:(UICollectionViewLayout *)layout completion:(nullable UICollectionViewLayoutInteractiveTransitionCompletion)completion NS_AVAILABLE_IOS(7_0);//准备好动画设置后，我们需要调用下面的方法进行布局动画的展示，之后会调用上面方法的block回调- (void)finishInteractiveTransition NS_AVAILABLE_IOS(7_0);//调用这个方法取消上面的布局动画设置，之后也会进行上面方法的block回调- (void)cancelInteractiveTransition NS_AVAILABLE_IOS(7_0);//获取分区数- (NSInteger)numberOfSections;//获取某一分区的item数- (NSInteger)numberOfItemsInSection:(NSInteger)section;//下面两个方法获取item或者头尾视图的layout属性，这个UICollectionViewLayoutAttributes对象//存放着布局的相关数据，可以用来做完全自定义布局，后面博客会介绍- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;//获取某一点所在的indexpath位置- (nullable NSIndexPath *)indexPathForItemAtPoint:(CGPoint)point;//获取某个cell所在的indexPath- (nullable NSIndexPath *)indexPathForCell:(UICollectionViewCell *)cell;//根据indexPath获取cell- (nullable UICollectionViewCell *)cellForItemAtIndexPath:(NSIndexPath *)indexPath;//获取所有可见cell的数组- (NSArray&lt;__kindof UICollectionViewCell *&gt; *)visibleCells;//获取所有可见cell的位置数组- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleItems;//下面三个方法是iOS9中新添加的方法，用于获取头尾视图- (UICollectionReusableView *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);- (NSArray&lt;UICollectionReusableView *&gt; *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);//使视图滑动到某一位置，可以带动画效果- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;//下面这些方法用于动态添加，删除，移动某些分区获取items- (void)insertSections:(NSIndexSet *)sections;- (void)deleteSections:(NSIndexSet *)sections;- (void)reloadSections:(NSIndexSet *)sections;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView系列六——将布局从平面应用到空间]]></title>
    <url>%2F2019%2F01%2F10%2FUICollectionView%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94%E5%B0%86%E5%B8%83%E5%B1%80%E4%BB%8E%E5%B9%B3%E9%9D%A2%E5%BA%94%E7%94%A8%E5%88%B0%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[一、引言前面，我们将布局由线性的瀑布流布局扩展到了圆环布局，这使我们使用UICollectionView的布局思路大大迈进了一步，这次，我们玩的更加炫一些，想办法将布局应用到空间。之前在管理布局的item的具体属性的类UICollectionViewLayoutAttributrs类中，有transform3D这个属性，通过这个属性的设置，我们真的可以在空间的坐标系中进行布局设计。iOS系统的控件中，也并非没有这样的先例，UIPickerView就是很好的一个实例，这篇博客，我们就通过使用UICollectionView实现一个类似系统的UIPickerView的布局视图，来体会UICollectionView在3D控件布局的魅力。系统的pickerView效果如下： 二、先来实现一个炫酷的滚轮空间布局万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout：123@interface MyLayout : UICollectionViewLayout@end 对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。 至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。 在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码：12345678910111213141516171819202122232425- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.MyLayout * layout = [[MyLayout alloc]init];UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];collect.delegate=self;collect.dataSource=self;[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;];[self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123;return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123;return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)];label.text = [NSString stringWithFormat:@&quot;我是第%ld行&quot;,(long)indexPath.row];[cell.contentView addSubview:label];return cell;&#125; 上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。 在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组：12345678-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;NSMutableArray * attributes = [[NSMutableArray alloc]init];//遍历设置每个item的布局属性for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123;[attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]];&#125;return attributes;&#125; 之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法：12345678910111213-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123;//创建一个item布局属性类UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];//获取item的个数int itemCounts = (int)[self.collectionView numberOfItemsInSection:0];//设置每个item的大小为260*100atti.size = CGSizeMake(260, 100); /*后边介绍的代码添加在这里*/ return atti;&#125; 上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。 首先，我们先将所有的item的位置都设置为collectionView的中心：1atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); 这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下： 很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码:12345678910111213141516//创建一个transform3D类//CATransform3D是一个类似矩阵的结构体//CATransform3DIdentity创建空得矩阵CATransform3D trans3D = CATransform3DIdentity;//这个值设置的是透视度，影响视觉离投影平面的距离trans3D.m34 = -1/900.0;//下面这些属性 后面会具体介绍//这个是3D滚轮的半径CGFloat radius = 50/tanf(M_PI*2/itemCounts/2);//计算每个item应该旋转的角度CGFloat angle = (float)(indexPath.row)/itemCounts*M_PI*2;//这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加//第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0);//进行设置atti.transform3D = trans3D; 对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下： 通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示： 每个item旋转的弧度就是其索引/(2*pi)。 通过上面的设置，我们再运行代码，效果如下： 仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下： 我们继续在刚才的代码后面添加这行代码： 12 //这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移 trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); 再次运行，效果如下： 布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。 三、让滚轮滑动起来 通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果 首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域： 123 -(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]); &#125; 这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法： 12345 //返回yes，则一有变化就会刷新布局 -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES; &#125; 将上面的布局的中心点设置加上一个动态的偏移量： 1 atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); 现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理： 12345 //获取当前的偏移量 float offset = self.collectionView.contentOffset.y; //在角度设置上，添加一个偏移角度 float angleOffset = offset/self.collectionView.frame.size.height; CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts*M_PI*2; 再看看效果，没错，就是这么简单，滚轮已经转了起来。 四、让其循环滚动的逻辑 我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下： 123456789 -(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //小于半屏 则放到最后一屏多半屏 if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10*400); //大于最后一屏多一屏 放回第一屏 &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10*400); &#125; &#125; 因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配： 在viewController中： 12 //一开始将collectionView的偏移量设置为1屏的偏移量 collect.contentOffset = CGPointMake(0, 400); 在layout类中： 1234 //将滚动范围设置为(item总数+2)*每屏高度 -(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2)); &#125; 12 //将计算的具体item角度向前递推一个 CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts*M_PI*2; OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！ http://pan.baidu.com/s/1jGCmbKM]]></content>
  </entry>
</search>
