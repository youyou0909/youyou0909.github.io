<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CGAffineTransform和CATransform3D原理]]></title>
    <url>%2F2019%2F01%2F23%2F17CGAffineTransform%E5%92%8CCATransform3D%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[####简述CGAffineTransform是用来做View层2D的形变的，UIView有个属性transform的类型就是CGAffineTransformCATransform3D是用来做layer层3D的形变的，CALayer也有个属性transform的类型就是CATransform3D 那么CGAffineTransform和CATransform3D的原理是什么呢？ ###先来看CGAffineTransform查看源码发现这是个结构体1234struct CGAffineTransform &#123;CGFloat a, b, c, d;CGFloat tx, ty;&#125;; 我们先来看下平移的方法CGAffineTransformMakeTranslation(CGFloat tx,CGFloat ty)的原理是什么呢？ 12345/* Return a transform which translates by `(tx, ty)&apos;:t&apos; = [ 1 0 0 1 tx ty ] */CG_EXTERN CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx,CGFloat ty) CG_AVAILABLE_STARTING(10.0, 2.0); 1234提示：为了把二维图形的变化统一在一个坐标系里，这里用到了齐次坐标的概念，即把一个二维图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成。 那么，CGAffineTransform结构体中的参数用矩阵来表示，如下： |a b 0| |c d 0| |tx ty 1| 运算的原理：设原坐标为(X,Y,1),通过矩阵运算如下：123|a b 0|[X,Y,1] |c d 0| = [aX + cY + tx bX + dY + ty 1]|tx ty 1| 矩阵运算后的坐标[aX + cY + tx bX + dY + ty 1] 我们将 t’ = [ 1 0 0 1 tx ty ]代入公式[aX + cY + tx bX + dY + ty 1]中1[aX + cY + tx bX + dY + ty 1] = [X + tx , Y + ty, 1] 我们发现X坐标向左移动了tx,Y坐标向下移动了ty，这就是方法CGAffineTransformMakeTranslation(CGFloat tx,CGFloat ty)的原理 同样的道理，CGAffineTransform的所有方法的原理都是通过这种矩阵的运算，来实现坐标的变换的 ###再来看看 CATransform3DCATransform3D也是结构体，这里也是引入齐次坐标的概念，将三维图形的变化用四维矩阵来表示。1234567struct CATransform3D&#123;CGFloat m11, m12, m13, m14;CGFloat m21, m22, m23, m24;CGFloat m31, m32, m33, m34;CGFloat m41, m42, m43, m44;&#125;; 设原坐标为(X,Y,Z,1)，通过矩阵运算的到1234567[m11, m12, m13, m14][m21, m22, m23, m24][X,Y,Z,1] [m31, m32, m33, m34] = [m11X+ m21Y + m31Z + m41,m12X+m22Y+m32Z+m42,m13X+m23Y+m33Z+m43,m14+m24+m34+m44];[m41, m42, m43, m44] 我们还是来看平移的方法CATransform3DMakeTranslation (CGFloat tx,CGFloat ty, CGFloat tz) 1234/* Returns a transform that translates by &apos;(tx, ty, tz)&apos;:* t&apos; = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1]. */CATransform3D CATransform3DMakeTranslation (CGFloat tx,CGFloat ty, CGFloat tz) 把t’ = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1]代入公式 [m11X+ m21Y + m31Z + m41,m12X+m22Y+m32Z+m42,m13X+m23Y+m33Z+m43,m14+m24+m34+m44]; (X,Y,Z,1) = （X + tx,Y+ty,Z+tz,1）即X、Y、Z坐标的平移CATransform3D其他方法的原理是类似的就不啰嗦了 ####最后再附上CGAffineTransform和CATransform3D相互转化的API 1234567/* Return a transform with the same effect as affine transform &apos;m&apos;. */CATransform3D CATransform3DMakeAffineTransform (CGAffineTransform m)/* Returns the affine transform represented by &apos;t&apos;. If &apos;t&apos; can not be* represented exactly by an affine transform the returned value is* undefined. */CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t) 以上，懂了原理之后是不是感觉其实很简单的呢]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 添加票据到wallet]]></title>
    <url>%2F2019%2F01%2F11%2F18saveToWallet%2F</url>
    <content type="text"><![CDATA[wallet的前身为passbook，2015年WWDC大会苹果正式改名wallet，passbook是苹果2012年iOS6开放出来的新功能.可以帮助用户管理五种类型（Boarding passes（登机牌），Coupons（优惠券），Store cards（购物卡），Event tickets（入场券），Generic（通用卡））的票据 在iOS中一个Pass其实就是一个.pkpass文件，事实上它是一个Zip压缩包，只是这个压缩包要按照一定的目录结构来设计如何创建一个Pass可以参考Apple的文档https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/YourFirst.html#//apple_ref/doc/uid/TP40012195-CH2-SW1 12345678910111213141516171819202122232425262728293031323334353637383940414243-(void)addPassbookView:(NSData *)date&#123; NSError *error = nil; BOOL passEnbale = [PKPassLibrary isPassLibraryAvailable];//检查pass是否可用 if (![PKPassLibrary isPassLibraryAvailable]) &#123;// dispatch_async(dispatch_get_main_queue(), ^&#123; //[[WaitDialogFullS sharedWaitDialog] endLoading]; [[[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;PassKit not available&quot; delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles: nil] show]; &#125;); return; &#125; if (passEnbale) &#123; PKPass *onePass = [[PKPass alloc] initWithData:date error:&amp;error]; if (error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; ZNLog(@&quot;!!!!!ERROR:%@&quot;,[error description]); UIAlertView *alert = [[UIAlertView alloc]initWithTitle:GDLocalizedString(@&quot;jpyd_Friendlyreminder&quot;) message:GDLocalizedString(@&quot;sy_onePass&quot;) delegate:nil cancelButtonTitle:GDLocalizedString(@&quot;jpyd_ok&quot;) otherButtonTitles:nil, nil]; [alert show]; [alert release]; &#125;); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; PKAddPassesViewController *passAddViewController = [[[PKAddPassesViewController alloc] initWithPass:onePass]autorelease]; passAddViewController.delegate = self; ChinaEastViewController *app = [ChinaEastViewController sharedBankcommViewController]; //Application tried to present a nil modal view controller on target .修改听云，李良 if (passAddViewController) &#123; [app presentViewController:passAddViewController animated:YES completion:^&#123; // [[WaitDialogFullS sharedWaitDialog] endLoading]; &#125;]; &#125; &#125;); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS中的@synthesize]]></title>
    <url>%2F2019%2F01%2F10%2F11iOS%E4%B8%AD%E7%9A%84%40synthesize%2F</url>
    <content type="text"><![CDATA[常见的有两种用法 其实是一个意思 @synthesize student; 等价于 @synthesize student = student @synthesize student = _student ARC下 通过@property声明的属性，编译器会自动声明对应的成员变量和getter/setter方法 而@synthesize student = _student就是程序猿自己显式地声明属性对应的成员变量，而不用编译器自生成的我们知道getter和setter方法里面操作的其实就是属性对应的成员变量 成员变量其实本质上就是一个变量指针 那么调用两者有什么区别呢？12self.name = @&quot;我信你个鬼&quot;;_name = @&quot;我信你个大头鬼&quot;; self.name本质上是调用的setter方法setName() 而setter方法是依赖于@property的属性修饰符的，比如retain，assign等属性。也就是会影响其引用计数 而_name = @”我信你个大头鬼” 只是变量的赋值 不涉及retain、assign等]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用解决办法]]></title>
    <url>%2F2019%2F01%2F10%2F12Mac%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、命令 lsof -i tcp:port （port替换成端口号，比如8081）可以查看该端口被什么程序占用，并显示pid，方便KILL 2、使用kill -9 + pid 3、重启xcode]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift String和NSDate的相互转化]]></title>
    <url>%2F2019%2F01%2F10%2F14Swift%20%20String%E5%92%8CNSDate%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[####1.String 转化成 NSDate :通常我在提交数据的时候时间格式都是14位,例如:”20161224191234”, 为了开发方便,需要把字符串转化成 NSDatelet dateString = “20161224191234” let formatter = NSDateFormatter()formatter.dateFormat = “yyyyMMddHHmmss”formatter.dateFromString(dateString) 这里的 dateFormat 格式要跟你自己的日期字符串格式一样, HH 为24小时制须大写,如不大写,上面转换出来结果为 nil. ####2.NSDate 转化成 String var normalTime:String{ let formatter = NSDateFormatter() formatter.dateFormat = “yyyy-MM-dd HH:mm:ss” return formatter.stringFromDate(NSDate()) } 这样结果就是2016-12-24 19:12:34的格式,格式由自己需求来定 ####3.由日期判断是星期几 扩展 NSDate,写一个方法 extension NSDate{ func resultWeek()-&gt;Int{ let interval = self.timeIntervalSince1970 let day = Int(interval/86400) return (day-3)%7 } } 上面的&quot;20161224191234&quot;判断一下是周几 let weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;] let week = weeks[formatter.dateFromString(dateString)!.resultWeek()] 结果是星期六 ####4.判断两个日期时间差 let firstDate = &quot;2016-09-24&quot; let secondDate = &quot;2016-12-24&quot; let cformatter = NSDateFormatter() cformatter.dateFormat = &quot;yyyy-MM-dd&quot; let sDate = cformatter.dateFromString(firstDate) let cDate = cformatter.dateFromString(secondDate) let intervals = cDate?.timeIntervalSinceDate(sDate!) //时间差(单位是秒) let day_seconds = 24*3600 //一天的秒数 let days = Int(intervals!)/day_seconds //结果就是两个日期的时间差(单位是天)]]></content>
  </entry>
  <entry>
    <title><![CDATA[tableviewcell注册和不注册的区别及用法]]></title>
    <url>%2F2019%2F01%2F10%2F15tableviewcell%E6%B3%A8%E5%86%8C%E5%92%8C%E4%B8%8D%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注册和不注册的区别主要看下面这两个方法： 1234567- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.(返回给代理一个已经分配的cell，代替一个新的cell，如果没有已分配的cell，则返回nil，使用这个方法就不需要注册了)- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 如果cell的identifier是注册过的，那么这个新列出的方法保证返回一个cell (有分配的就返回已分配的cell，没有返回新的cell)并适当调整大小，可省略cell空值判断步骤，用这个方法cell必须注册,不是自定义的cell，UITableViewCell也要注册]]></content>
  </entry>
  <entry>
    <title><![CDATA[TCP与UDP区别]]></title>
    <url>%2F2019%2F01%2F10%2F16TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 UDP补充：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。 TCP补充：TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2F1hello-world%2F</url>
    <content type="text"><![CDATA[今天是个人博客开通的第一天，搞了半天终于好了，好激动！！！以前自己做的学习记录有在本地文件的，有在备忘录的，有在简书的。。。反正就是各种地方，很多慢慢都找不到了。这次正好最近闲下来整理下。慢慢的都放到自己的博客中。 我有一头小毛驴，可是我从来都不骑。]]></content>
  </entry>
</search>
